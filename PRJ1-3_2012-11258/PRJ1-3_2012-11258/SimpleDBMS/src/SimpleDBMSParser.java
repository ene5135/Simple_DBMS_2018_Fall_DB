/* Generated By:JavaCC: Do not edit this line. SimpleDBMSParser.java */
// import

import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;
import com.sleepycat.je.LockMode;
import com.sleepycat.bind.serial.SerialBinding;
import com.sleepycat.bind.serial.StoredClassCatalog;
import com.sleepycat.bind.EntryBinding;
import com.sleepycat.je.OperationStatus;

import java.io.File;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collections;


/* PRJ2 #7 : My table, attr structure */
  class Table implements Serializable
  {
        String tableName;
        ArrayList<Attribute> attributes;
        ArrayList<String> referencedBy; // name of table that reference this table.
        ArrayList<ForeignKey> FKs;
        ArrayList<String> PK;
        ArrayList<ArrayList<String>> records;

        Table()
        {
          tableName = null;
          attributes = new ArrayList<Attribute>();
          referencedBy = new ArrayList<String>();
          FKs = new ArrayList<ForeignKey>();
          PK = new ArrayList<String>();
          records = new ArrayList<ArrayList<String>>();
        }

    void makeReferencingRecordsNull(ArrayList<String> targetRecord)
    {
          for(String refTableName : referencedBy)
          {
            DatabaseEntry theKey = null;
            try {
                theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        DatabaseEntry theData = new DatabaseEntry();
        if(!SimpleDBMSParser.getTableFromDB(theKey, theData)) // not found
        {
          //this can not be reached
                        System.out.println("can not reach here : checkNonNullableReferencing");
        }
        else // found
        {
              Table refTable = (Table) SimpleDBMSParser.entryBinding.entryToObject(theData);
              ForeignKey refTableFK = refTable.getFKByRefTableName(tableName);
              ArrayList<String> referencingAttrs = refTableFK.getAttrs();
              ArrayList<String> referencedAttrs = refTableFK.getRefedAttrs();
              Boolean thereAreNonNullAttr = false;
              ArrayList<ArrayList<String>> refTableRecords = refTable.getRecords();

              for(String cursor : referencingAttrs)
              {
                        if(!refTable.getAttributeByName(cursor).getNullable())
                        {
                          thereAreNonNullAttr = true;
                          break;
                        }
              }
                  if(!thereAreNonNullAttr)// non-null col이 하나도 없어야 null로 만들 수 있음
                  {

                          ArrayList<Integer> referencingAttrsIndex = new ArrayList<Integer>();
                          for(String cursor : referencingAttrs)
                          {
                                referencingAttrsIndex.add(refTable.getIndexByAttrName(cursor));
                          }

                          ArrayList<Integer> referencedAttrsIndex = new ArrayList<Integer>();
                          for(String cursor : referencedAttrs)
                          {
                                referencedAttrsIndex.add(getIndexByAttrName(cursor));
                          }

                          int j=0;
                          for(ArrayList<String> recCursor : refTableRecords) // 쪼는 테이블 레코드들 보면서 지우려는 레코드랑 같은 레코드 존재하는지 확인
                          // 위에서 nonNullattr가 있단걸 확인했으므로 겹치면 못지움
                          {
                            Boolean temp = true;
                                for(int i=0;i<referencedAttrsIndex.size();i++)
                                {
                                  if(!targetRecord.get(referencedAttrsIndex.get(i)).equals(recCursor.get(referencingAttrsIndex.get(i))))
                                  {
                                        temp = false;
                                  }
                                }
                                if(temp)// 모든 attr가 같으면
                                {
                                  for(int i=0;i<referencingAttrsIndex.size();i++) // null로 바꾸고
                                  {
                                        recCursor.set(referencingAttrsIndex.get(i),"null");
                                  }
                                  refTableRecords.set(j,recCursor); // 바꿔끼우고
                                  refTable.setRecord(refTableRecords);

                                        //db에 저장
                                  SimpleDBMSParser.entryBinding.objectToEntry(refTable,theData);
                                  SimpleDBMSParser.myDatabase.put(null, theKey, theData); // overwrite updated record
                                  SimpleDBMSParser.myDatabase.sync();
                                }
                                j++;
                          }

                  }
            }
          }
    }

        Boolean canBeDeleted(ArrayList<String> targetRecord)
        {
          for(String refTableName : referencedBy)
          {
            DatabaseEntry theKey = null;
            try {
                theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        DatabaseEntry theData = new DatabaseEntry();
        if(!SimpleDBMSParser.getTableFromDB(theKey, theData)) // not found
        {
          //this can not be reached
                        System.out.println("can not reach here : checkNonNullableReferencing");
        }
        else // found
        {
              Table refTable = (Table) SimpleDBMSParser.entryBinding.entryToObject(theData);
              ForeignKey refTableFK = refTable.getFKByRefTableName(tableName);
              ArrayList<String> referencingAttrs = refTableFK.getAttrs();
              ArrayList<String> referencedAttrs = refTableFK.getRefedAttrs();
              Boolean thereAreNonNullAttr = false;
              ArrayList<ArrayList<String>> refTableRecords = refTable.getRecords();

              for(String cursor : referencingAttrs)
              {
                        if(!refTable.getAttributeByName(cursor).getNullable())
                        {
                          thereAreNonNullAttr = true;
                          break;
                        }
              }
                  if(!thereAreNonNullAttr)// non-null col이 하나도 없으면 걍 가능, 다음 쪼는 테이블로 넘어감
                    continue;

                  ArrayList<Integer> referencingAttrsIndex = new ArrayList<Integer>();
                  for(String cursor : referencingAttrs)
                  {
                        referencingAttrsIndex.add(refTable.getIndexByAttrName(cursor));
                  }

                  ArrayList<Integer> referencedAttrsIndex = new ArrayList<Integer>();
                  for(String cursor : referencedAttrs)
                  {
                        referencedAttrsIndex.add(getIndexByAttrName(cursor));
                  }

                  for(ArrayList<String> recCursor : refTableRecords) // 쪼는 테이블 레코드들 보면서 지우려는 레코드랑 같은 레코드 존재하는지 확인
                  // 위에서 nonNullattr가 있단걸 확인했으므로 겹치면 못지움
                  {
                    Boolean temp = true;
                        for(int i=0;i<referencedAttrsIndex.size();i++)
                        {
                          if(!targetRecord.get(referencedAttrsIndex.get(i)).equals(recCursor.get(referencingAttrsIndex.get(i))))
                          {
                                temp = false;
                          }
                        }
                        if(temp)// 모든 attr가 같으면
                          return false;
                  }

            }
          }
          return true;
        }

        Integer getIndexByAttrName(String attrName)
        {
          Integer i = 0;
          for(Attribute cursor : attributes)
          {
                if(cursor.getAttrName().equalsIgnoreCase(attrName))
                {
                  return i;
                }
                i++;
          }
          return -1;// can not be reached
        }

        ForeignKey getFKByRefTableName(String refTableName)
        {
          for(ForeignKey cursor : FKs)
          {
                if(cursor.getRefTableName().equalsIgnoreCase(refTableName))
                  return cursor;
          }
          return null;
        }

//foreign key 하나씩 돌면서 foreign key attr 인덱스 표시하고 해당 테이블의 레코드 가져와서
// 그 테이블의 foreign key attr 표시해서 쭉 비교

        void setRecord(ArrayList<ArrayList<String>> newRecords)
        {
          records = newRecords;
        }

        Boolean checkForeignConstraint(ArrayList<String> newRecord)
        {
          for(ForeignKey foreignKeyCursor : FKs)
          {

            String refTableName = foreignKeyCursor.getRefTableName();

            DatabaseEntry theKey = null;
            try {
                theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        DatabaseEntry theData = new DatabaseEntry();
        if(!SimpleDBMSParser.getTableFromDB(theKey, theData)) // not found
        {
          //this can not be reached
                        System.out.println("Create table has failed: foreign key references non existing table");
                        SimpleDBMSParser.ReInit(System.in);
        }
        else // found
        {
              Table refTable = (Table) SimpleDBMSParser.entryBinding.entryToObject(theData);
                  ArrayList<String> referencingAttrs = foreignKeyCursor.getAttrs();
                  ArrayList<String> referencedAttrs = foreignKeyCursor.getRefedAttrs();

                  ArrayList<String> sortedNewRecord = new ArrayList<String>(Collections.nCopies(referencingAttrs.size(),""));
                  ArrayList<String> foreignKeyIndexForNewRecord = new ArrayList<String>(Collections.nCopies(attributes.size(),""));
// referencing attr 순서에 맞는 인덱스 얻기
                  int i = 0;
                  for(Attribute cursor : attributes)
                  {
                    int j = 0;
                        for(String temp : referencingAttrs)
                    {
                          if(temp.equalsIgnoreCase(cursor.getAttrName()))
                          {
                            foreignKeyIndexForNewRecord.set(i,Integer.toString(j));
                                break;
                          }
                          j++;
                    }
                        if(j==referencingAttrs.size())
                          foreignKeyIndexForNewRecord.set(i,"null");
                        i++;
                  }
// 그 인덱스에 맞게 소팅
                  i = 0;
                  for(String cursor : newRecord)
                  {
                    if(!foreignKeyIndexForNewRecord.get(i).equals("null"))
                    {
                          sortedNewRecord.set(Integer.parseInt(foreignKeyIndexForNewRecord.get(i)),cursor);
                        }
                        i++;
                  }

                  Boolean tempBool = false;
                  ArrayList<ArrayList<String>> refedRecords = refTable.getRecords();
              for(ArrayList<String> recCursor : refedRecords)
              {

                ArrayList<String> sortedRefedRecord = new ArrayList<String>(Collections.nCopies(referencedAttrs.size(),""));
                    ArrayList<String> foreignKeyIndexForRefedRecord = new ArrayList<String>(Collections.nCopies(refTable.getAttrs().size(),""));
                        // referenced attr 순서에 맞는 인덱스 얻기
                          i = 0;
                          for(Attribute cursor : refTable.getAttrs())
                          {
                            int j = 0;
                                for(String temp : referencedAttrs)
                            {
                                  if(temp.equalsIgnoreCase(cursor.getAttrName()))
                                  {
                                        foreignKeyIndexForRefedRecord.set(i,Integer.toString(j));
                                        break;
                                  }
                                  j++;
                            }
                                if(j==referencedAttrs.size())
                                  foreignKeyIndexForRefedRecord.set(i,"null");
                                i++;
                          }
        // 그 인덱스에 맞게 소팅
                          i = 0;
                          for(String cursor : recCursor)
                          {
                                if(!foreignKeyIndexForRefedRecord.get(i).equals("null"))
                        {
                                  sortedRefedRecord.set(Integer.parseInt(foreignKeyIndexForRefedRecord.get(i)),cursor);
                                }
                                i++;
                          }

                          // 이제 sortedRefedRecord랑  sortedNewRecord 비교해서 bool 값 조지면 됨			  
                          if(equalsStringList(sortedNewRecord, sortedRefedRecord))
                            tempBool = true;
              }
              if(!tempBool)
                return false;
        }
          }

          return true;
        }

        Boolean equalsStringList(ArrayList<String> l, ArrayList<String> r)
        {
          Boolean temp = true;
          for(int i = 0; i<l.size();i++)
          {
            if(!l.get(i).equals(r.get(i)))
                  temp = false;
          }
          return temp;
        }

        // primary key인 value가 겹치는게 있는지, true : good, false : bad
        Boolean checkPrimaryConstraint(ArrayList<String> newRecord)
        {
          int i=0;
          ArrayList<ArrayList<String>> temp = new ArrayList<ArrayList<String>>(records);
          for(Attribute cursor : attributes)
          {
            if(isPK(cursor.getAttrName())||PK.isEmpty()) // pk가 없으면 전체 다 봄.
            {
              for(int j=0;j<temp.size();j++)
              {
                if(!temp.get(j).get(i).equals(newRecord.get(i)))
                {
                  temp.remove(j);
                  j--;
                }
              }
            }
            i++;
          }

          if(temp.isEmpty())
          {
                return true;
          }
          else
          {
            return false;
          }
        }

        ArrayList<ArrayList<String>> getRecords()
        {
          return records;
        }

        void markPKsNotNull()
        {
          for(String PKCursor : PK)
          {
                for(Attribute attrCursor : attributes)
                {
                  if(PKCursor.equalsIgnoreCase(attrCursor.getAttrName()))
                        attrCursor.setNullable(false);
                }
          }
        }
        static Boolean containsCaseInsen(ArrayList<String> arrayList, String target)
    {
          Boolean result = false;
          for(String cursor : arrayList)
          {
            result = result || cursor.equalsIgnoreCase(target);
          }
          return result;
    }
        Boolean containsAttr(String attrName)
        {
          Boolean result = false;
          for(Attribute cursor : attributes)
          {
                if(cursor.getAttrName().equalsIgnoreCase(attrName))
                  result = true;
          }
          return result;
        }
        Attribute getAttributeByName(String attrName)
        {
          Attribute result = null;
          for(Attribute cursor : attributes)
          {
                if(cursor.getAttrName().equalsIgnoreCase(attrName))
                  return cursor;
          }
          return result;
        }
        ArrayList<String> getPK()
        {
          return PK;
        }
        void addToRefBy(String referencingTableName)
        {
          referencedBy.add(referencingTableName);
        }
        ArrayList<ForeignKey> getFKs()
        {
          return FKs;
        }
        void deleteFromRefBy(String target)
        {
          referencedBy.remove(target);
        }
        Boolean isFK(String attrName)
        {
          Boolean result = false;
          for(ForeignKey cursor : FKs)
          {
            result = result || containsCaseInsen(cursor.getAttrs(), attrName);
          }
          return result;
        }
        Boolean isPK(String attrName)
        {
          return containsCaseInsen(PK, attrName);
        }
        ArrayList<Attribute> getAttrs()
        {
          return attributes;
        }
        void addFK(ForeignKey newFK)
        {
          FKs.add(newFK);
        }
        void addPKs(ArrayList<String> newPKs)
        {
          PK.addAll(newPKs);
        }
        String getTableName()
        {
          return tableName;
        }
        Boolean isReferenced()
        {
          return (!referencedBy.isEmpty());
        }
        void setTableName(String argTableName)
        {
          tableName = argTableName;
        }
        void addAttr(Attribute attr)
        {
          attributes.add(attr);
        }
  }

  class Pair<E,F> implements Serializable
  {
        E left;
        F right;
        Pair(E l, F r)
        {
          left = l;
          right = r;
        }

        E getLeft()
        {
          return left;
        }
        F getRight()
        {
          return right;
        }
  }

  class Attribute implements Serializable
  {
        String tableName;
        String attrName;
        String type;
        Boolean nullable;

        Attribute()
        {
          tableName = null;
          attrName = null;
          type = null;
          nullable = true;
        }
        Attribute(String argTN, String argAN, String argType, Boolean argNullable)
        {
          tableName = argTN;
          attrName = argAN;
          type = argType;
          nullable = argNullable;
        }

        String getAttrName()
        {
          return attrName;
        }
        String getType()
        {
          return type;
        }
        Boolean getNullable()
        {
          return nullable;
        }
        void setTableName(String argTN)
        {
          tableName = argTN;
        }
        void setAttrName(String argAN)
        {
          attrName = argAN;
        }
        void setType(String argType)
        {
          type = argType;
        }
        void setNullable(Boolean argNullable)
        {
          nullable = argNullable;
        }
  }

  class ForeignKey implements Serializable // Foreign key : list to list referencing
  {
        ArrayList<String> referencingAttrs;
        String referencedTable;
        ArrayList<String> referencedAttrs;

        ForeignKey(ArrayList<String> argReferencing, String argReferencedTable, ArrayList<String> argReferenced)
        {
          referencingAttrs = argReferencing;
          referencedTable = argReferencedTable;
          referencedAttrs = argReferenced;
        }

        String getRefTableName()
        {
          return referencedTable;
        }
        ArrayList<String> getAttrs()
        {
          return referencingAttrs;
        }
        ArrayList<String> getRefedAttrs()
        {
          return referencedAttrs;
        }
  }


////////////// PRJ2 #9 : need these classes to execute column definition before table constraint definition for any order of input statement
  class TableElementList implements Serializable
  {
        ArrayList<ColumnDef> columnDefList;
        ArrayList<TableConstraintDef> tableConstraintDefList;

        TableElementList()
        {
          columnDefList = new ArrayList<ColumnDef>();
          tableConstraintDefList = new ArrayList<TableConstraintDef>();
        }

        ArrayList<TableConstraintDef> getConstDefList()
        {
          return tableConstraintDefList;
        }
        ArrayList<ColumnDef> getColumnDefList()
        {
          return columnDefList;
        }
        void addColumnDef(ColumnDef newDef)
        {
          columnDefList.add(newDef);
        }
        void addTableConstraintDef(TableConstraintDef newDef)
        {
          tableConstraintDefList.add(newDef);
        }
  }

  class ColumnDef implements Serializable
  {
        String columnName;
        String dataType;
        Boolean nullable;

        ColumnDef(String argColName, String argType, Boolean argNullable)
        {
          columnName = argColName;
          dataType = argType;
          nullable = argNullable;
        }

        String getColumnName()
        {
          return columnName;
        }
        String getDataType()
        {
          return dataType;
        }
        Boolean getNullable()
        {
          return nullable;
        }
  }

  class TableConstraintDef implements Serializable
  {
        String type; // "FK" or "PK"
        ArrayList<String> attrs;
        String referencedTable; // for only FK
        ArrayList<String> referencedAttrs; // for only FK

        TableConstraintDef(String argType, ArrayList<String> argAttrs)
        {
          type = argType;
          attrs = argAttrs;
          referencedTable = null;
          referencedAttrs = null;
        }
        TableConstraintDef(String argType, ArrayList<String> argAttrs, String argReferencedTable, ArrayList<String> argReferencedAttrs)
        {
          type = argType;
          attrs = argAttrs;
          referencedTable = argReferencedTable;
          referencedAttrs = argReferencedAttrs;
        }

        String getRefTableName()
        {
          return referencedTable;
        }
        ArrayList<String> getRefAttrs()
        {
          return referencedAttrs;
        }
        ArrayList<String> getAttrs()
        {
          return attrs;
        }
        String getType()
        {
          return type;
        }
  }

public class SimpleDBMSParser implements SimpleDBMSParserConstants {
  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE = 2;
  public static final int PRINT_DESC = 3;
  public static final int PRINT_SELECT = 4;
  public static final int PRINT_INSERT = 5;
  public static final int PRINT_DELETE = 6;
  public static final int PRINT_SHOW_TABLES = 7;

  // Environment & Database declarations
  public static Environment myDbEnvironment = null;
  public static Database myDatabase = null;
  public static Database myClassDb = null;
  public static Cursor cursor = null;
  public static StoredClassCatalog scc = null;
  public static EntryBinding entryBinding = null;
  public static DatabaseEntry foundKey = null;
  public static DatabaseEntry foundData = null;
  public static ArrayList<String> currFromTables = null;
  public static ArrayList<String> currOriginalNames = null;

  public static void main(String args[]) throws ParseException
  {
        /* OPENING DB */

        // Open Database Environment or if not, create one.
        EnvironmentConfig envConfig = new EnvironmentConfig();
        envConfig.setAllowCreate(true);
        myDbEnvironment = new Environment(new File("db/"), envConfig);

        // Open Database or if not, create one.
        // Initializations
        DatabaseConfig dbConfig = new DatabaseConfig();
        dbConfig.setAllowCreate(true);
        dbConfig.setSortedDuplicates(false);
        dbConfig.setDeferredWrite(true); // PRJ2 #1 : set this option to use sync() function.
        myDatabase = myDbEnvironment.openDatabase(null, "sampleDatabase", dbConfig);
        dbConfig.setSortedDuplicates(false);
    myClassDb = myDbEnvironment.openDatabase(null, "classDb", dbConfig);
    scc = new StoredClassCatalog(myClassDb);
        entryBinding = new SerialBinding(scc,Table.class); // PRJ2 #0 : My DB stores <String(=key), Object(=value)>. Techniques to store object in value. using binding
        cursor = myDatabase.openCursor(null, null);
        foundKey = new DatabaseEntry();
        foundData = new DatabaseEntry();


    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
    System.out.print("DB_2012-11258> ");

    while (true)
    {
      try
      {
        parser.command();
      }
      catch (ParseException e)
      {
       // e.printStackTrace();
        printMessage(PRINT_SYNTAX_ERROR);
        SimpleDBMSParser.ReInit(System.in);
      }
      catch (Exception e)
      {
        System.out.println(e.getMessage());
        //e.printStackTrace();
        System.out.print("DB_2012-11258> ");
                SimpleDBMSParser.ReInit(System.in);
      }
    }
  }


/* PRJ2 #2 : this function put <Key(=String), Object > into DB. */
  public static void putObjectEntry(String keyString, Object obj) throws Exception
  {
        try {
          DatabaseEntry key;
          DatabaseEntry data;

          key = new DatabaseEntry(keyString.getBytes("UTF-8"));
          data = new DatabaseEntry();

          entryBinding.objectToEntry(obj,data); // PRJ2 #0 : My DB stores <String(=key), Object(=value)>. Techniques to store object in value.

          if(tableExist(keyString))
                // this exception must not be executed
                throw new Exception("Create table has failed: table with the same name already exists");
          myDatabase.putNoOverwrite(null, key, data);
          myDatabase.sync(); // PRJ2 #1 : To save db file immediately.
        } catch (DatabaseException de) {
          de.printStackTrace();
        } catch (UnsupportedEncodingException e) {
          e.printStackTrace();
        }
  }

//PRJ2 #6 : requested message should be removed
  public static void printMessage(int q)
  {
    //System.out.print("DB_2012-11258> ");
    switch(q)
    {
      case PRINT_SYNTAX_ERROR:
        System.out.println("Syntax error");
        break;
        /*
      case PRINT_CREATE_TABLE:
      	System.out.println("\'CREATE TABLE\' requested");
      	break;
      case PRINT_DROP_TABLE:
      	System.out.println("\'DROP TABLE\' requested");
      	break;
      case PRINT_DESC:
      	System.out.println("\'DESC\' requested");
      	break;
      case PRINT_SHOW_TABLES:
	    System.out.println("\'SHOW TABLES\' requested");
      	break;
      	*/
     /* case PRINT_SELECT:
      	System.out.println("\'SELECT\' requested");
      	break;*/
      /*case PRINT_INSERT:
      	System.out.println("\'INSERT\' requested");
      	break;*/
    /*  case PRINT_DELETE:
      	System.out.println("\'DELETE\' requested");
      	break;*/
    }
    System.out.print("DB_2012-11258> ");
  }

  static Boolean containsCaseInsen(ArrayList<String> arrayList, String target)
  {
        Boolean result = false;
        for(String cursor : arrayList)
        {
          result = result || cursor.equalsIgnoreCase(target);
        }
        return result;
  }

  static Boolean getTableFromDB(DatabaseEntry theKey, DatabaseEntry theData) // case insensitive get. not found = null
  {
    Boolean result = false;
        if (cursor.getFirst(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.NOTFOUND)
        { // empty db case
          return result;
        }
        else
        {
          do // traverse entire db
          {
            String res_key = null;
            String target = null;
            try {
                        target = new String(theKey.getData(), "UTF-8");
                                res_key = new String(foundKey.getData(), "UTF-8");
                } catch (UnsupportedEncodingException e) {
                        e.printStackTrace();
                }
            if(res_key.equalsIgnoreCase(target))
            {
              entryBinding.objectToEntry((Table) entryBinding.entryToObject(foundData),theData);
              try { theKey.setData(res_key.getBytes("UTF-8")); }
              catch (UnsupportedEncodingException e) {  e.printStackTrace(); }
              result = true;
              return result;
            }
          } while (cursor.getNext(foundKey, foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);
        }
        return result;
  }

  static void addAllReferencedBy(String tableName, TableElementList definitionList) throws Exception
  {
    ArrayList<TableConstraintDef> tableConstraintDefList = definitionList.getConstDefList();
        String refTableName;
        ArrayList<String> keyAttrs, refAttrs;

        for (TableConstraintDef cursor : tableConstraintDefList)
        {
          if(cursor.getType().equals("FK"))
          {
                keyAttrs = cursor.getAttrs();
            refTableName = cursor.getRefTableName();
            refAttrs = cursor.getRefAttrs();

            DatabaseEntry theKey = null;
            try {
                theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        DatabaseEntry theData = new DatabaseEntry();
        if(!getTableFromDB(theKey, theData)) // not found
        {
          //this can not be reached
          throw new Exception("Create table has failed: foreign key references non existing table");
        }
        else // found
        {
              Table retrievedTable = (Table) entryBinding.entryToObject(theData);

              retrievedTable.addToRefBy(tableName);
                  entryBinding.objectToEntry(retrievedTable,theData);
                  myDatabase.put(null, theKey, theData); // overwrite updated record
                  myDatabase.sync();
        }
          }
        }
  }

  static Boolean tableExist(String tableName)
  {
        DatabaseEntry theKey = null;
        try {
                theKey = new DatabaseEntry(tableName.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
        }
    DatabaseEntry theData = new DatabaseEntry();
    return getTableFromDB(theKey, theData);
  }

  static void deleteReference(Table table)
  {
    String referencedTableName;
    for(ForeignKey cursor : table.getFKs())
    {
      referencedTableName = cursor.getRefTableName();
      DatabaseEntry theKey = null;
          try {
                theKey = new DatabaseEntry(referencedTableName.getBytes("UTF-8"));
          } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
          }
      DatabaseEntry theData = new DatabaseEntry();
      if(!getTableFromDB(theKey, theData)) // not found
      {
        System.out.println("Fatal error : code cannot reach here(deleteReference())");
      }
      else // found
      {
            Table retrievedTable = (Table) entryBinding.entryToObject(theData);
            retrievedTable.deleteFromRefBy(table.getTableName());
            entryBinding.objectToEntry(retrievedTable,theData);
                myDatabase.put(null, theKey, theData); // overwrite updated record
                myDatabase.sync();
      }
    }
  }

/* PRJ2 #12 : this function check whether the attr is key or not and return the string like PRI, FOR, PRI/FOR
*/
  static String whatKey(Table table, String attrName)
  {
        String result = new String("");
        String slash = new String("");
        if(table.isPK(attrName))
        {
          result = result + "PRI";
          slash = "/";
        }
        if(table.isFK(attrName))
          result = result + slash + "FOR";

        return result;
  }

/* PRJ2 #10 : this function add new columns to table, traversing column definition list */
  static Table makeColumns(Table newTable, TableElementList definitionList) throws Exception
  {
        ArrayList<ColumnDef> columnDefList = definitionList.getColumnDefList();
        Attribute newAttr;
        String tableName = newTable.getTableName();
        String newColumnName, newColumnType;
        Boolean newColumnNullable;

        for (ColumnDef cursor : columnDefList)
        {
          newColumnName = cursor.getColumnName();
          newColumnType = cursor.getDataType();
          newColumnNullable = cursor.getNullable();

          for(Attribute attrCursor : newTable.getAttrs()) // check dup col
          {
            if(attrCursor.getAttrName().equalsIgnoreCase(newColumnName))
              throw new Exception("Create table has failed: column definition is duplicated");
          }
          if(newColumnType.equals("errorType"))
            throw new Exception("Char length should be over 0");

          newAttr = new Attribute(tableName, newColumnName, newColumnType, newColumnNullable);
          newTable.addAttr(newAttr);
        }

        return newTable;
  }

/* PRJ2 #11 : this function apply new constraints to table, traversing column definition list */
  static Table applyConstraints(Table newTable, TableElementList definitionList) throws Exception
  {
        ArrayList<TableConstraintDef> tableConstraintDefList = definitionList.getConstDefList();
        ForeignKey newForeignKey;
        String refTableName;
        ArrayList<String> keyAttrs, refAttrs;

        for (TableConstraintDef cursor : tableConstraintDefList)
        {
          if(cursor.getType().equals("PK"))
          {
            keyAttrs = cursor.getAttrs();
            if(!newTable.getPK().isEmpty()) // already exist pk
              throw new Exception("Create table has failed: primary key definition is duplicated");

            for(String strCursor : keyAttrs) // 존재하지 않는 컬럼을 primary key로 정의한 경우
                {
                  if(!newTable.containsAttr(strCursor))
                        throw new Exception("Create table has failed: '"+ strCursor +"' does not exists in column definition");
                }

            newTable.addPKs(keyAttrs);
            newTable.markPKsNotNull();
          }
          else // "FK" case
          {
            keyAttrs = cursor.getAttrs();
            refTableName = cursor.getRefTableName();
            refAttrs = cursor.getRefAttrs();

                DatabaseEntry theKey = null;
            try {
                theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        DatabaseEntry theData = new DatabaseEntry();
        if(!getTableFromDB(theKey, theData)) // not found
        {
          throw new Exception("Create table has failed: foreign key references non existing table");
        }

            Table retrievedTable = (Table) entryBinding.entryToObject(theData);

                ArrayList<Attribute> newTableAttrs = newTable.getAttrs();
                ArrayList<Attribute> refTableAttrs = retrievedTable.getAttrs();
                ArrayList<Attribute> newTableFKAttrs = new ArrayList<Attribute>();
                ArrayList<Attribute> refTableFKAttrs = new ArrayList<Attribute>();
                ArrayList<String> typeList = new ArrayList<String>();

                for(String strCursor : keyAttrs) // 존재하지 않는 컬럼을 foreign key로 정의한 경우
                {
                  if(!newTable.containsAttr(strCursor))
                        throw new Exception("Create table has failed: '"+ strCursor +"' does not exists in column definition");
                }
                for(String strCursor : refAttrs)
                {
                  if(!retrievedTable.containsAttr(strCursor)) // Foreign key가 존재하지 않는 컬럼을 참조한다면, ReferenceColumnExistenceError에 해당하는 메시지 출력
                        throw new Exception("Create table has failed: foreign key references non existing column");
                  if((!containsCaseInsen(retrievedTable.getPK(), strCursor)) || (retrievedTable.getPK().size() != refAttrs.size())) // Foreign key가 primary key가 아닌 컬럼을 참조한다면, 
                        throw new Exception("Create table has failed: foreign key references non primary key column");
                }

                // Foreign key의 타입과 foreign key가 참조하는 컬럼의 개수나 타입이 서로 다른 경우,
                // ReferenceTypeError에 해당하는 메시지 출력
                for(Attribute attrCursor : newTableAttrs)
                {
                  if(containsCaseInsen(keyAttrs, attrCursor.getAttrName()))
                    newTableFKAttrs.add(attrCursor);
                }
                for(Attribute attrCursor : refTableAttrs)
                {
                  if(containsCaseInsen(refAttrs, attrCursor.getAttrName()))
                    refTableFKAttrs.add(attrCursor);
                }

                for(Attribute attrCursor : newTableFKAttrs)
                {
                  typeList.add(attrCursor.getType());
                }
                for(Attribute attrCursor : refTableFKAttrs)
                {
                  typeList.remove(attrCursor.getType());
                }

                if((keyAttrs.size() != refAttrs.size())||(!typeList.isEmpty())) // number of foreign key col and refed col are different 
                  throw new Exception("Create table has failed: foreign key references wrong type");

                for(ForeignKey FKCursor : newTable.getFKs()) // PRJ2 #13 : additional error case. the column references multiple tables
                {
                  for(String newAttr : keyAttrs)
                  {
                        if(containsCaseInsen(FKCursor.getAttrs(), newAttr))
                          throw new Exception("Create table has failed: the column references multiple tables");
                  }
                }

            newForeignKey = new ForeignKey(keyAttrs, refTableName, refAttrs);
            newTable.addFK(newForeignKey);
          }
        }
        addAllReferencedBy(newTable.getTableName(), definitionList);

        return newTable;
  }


  // 리스트 내에 같은 스트링이 존재하는지 검사
  static Boolean checkDup(ArrayList<String> input)
  {
        for(String cursor : input)
        {
          ArrayList<String> temp = new ArrayList<String>(input);
          temp.remove(cursor);
          if(Table.containsCaseInsen(temp, cursor))
                return true;
        }
        return false;
  }

  static Boolean isType(String input)
  {
        if(input.equals("int") || input.equals("date") || input.equals("char"))
          return true;
        else
          return false;
  }

  // charString 의 양끝 ' 없에기
  static String removeQuote(String input)
  {
        return input.substring(1,input.length()-1);
  }

  //op : "<" | ">" | "=" | "<=" | ">=" | "!="
  static String compareTwoValues(String l, String op, String r, Boolean isInt)
  {
        if(l.equals("null") || r.equals("null"))
          return "unknown";

        if(op.equals("<"))
        {
          if(isInt)
            return String.valueOf(Integer.parseInt(l) < Integer.parseInt(r));
          return String.valueOf(l.compareTo(r) < 0);
        }
        else if(op.equals(">"))
        {
          if(isInt)
            return String.valueOf(Integer.parseInt(l) > Integer.parseInt(r));
          return String.valueOf(l.compareTo(r) > 0);
        }
        else if(op.equals("="))
        {
          if(isInt)
            return String.valueOf(Integer.parseInt(l) == Integer.parseInt(r));
          return String.valueOf(l.equals(r));
        }
        else if(op.equals("<="))
        {
          if(isInt)
            return String.valueOf(Integer.parseInt(l) <= Integer.parseInt(r));
          return String.valueOf(l.compareTo(r) <= 0);
        }
        else if(op.equals(">="))
        {
          if(isInt)
            return String.valueOf(Integer.parseInt(l) >= Integer.parseInt(r));
          return String.valueOf(l.compareTo(r) >= 0);
        }
        else if(op.equals("!="))
        {
          if(isInt)
            return String.valueOf(Integer.parseInt(l) != Integer.parseInt(r));
          return String.valueOf(!l.equals(r));
        }

        return "false"; // can not reach here

  }

  static Pair<Integer, String> getColIndexAndType(int tableIndex, String colName)
  {
        int i = 0;
        int result = 0;

        for(String cursor : currOriginalNames)
        {
          DatabaseEntry theKey = null;
          try {
                theKey = new DatabaseEntry(cursor.getBytes("UTF-8"));
          } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
          }
      DatabaseEntry theData = new DatabaseEntry();
      if(!getTableFromDB(theKey, theData)) // not found
      {
        System.out.println("Fatal error : code cannot reach here");
      }
      else // found
      {
        Table retrievedTable = (Table) entryBinding.entryToObject(theData);

        if(i == tableIndex)
        {
          int j = 0;
                  for(Attribute attrCursor : retrievedTable.getAttrs())
                  {
                        if(colName.equalsIgnoreCase(attrCursor.getAttrName()))
                          return new Pair<Integer, String>(result + j, attrCursor.getType());
                        j++;
                  }
        }
        else
                  result = result + retrievedTable.getAttrs().size();
      }
      i++;

        }
        return null; // can not reach here

  }

  static ArrayList<ArrayList<String>> carteProduct(ArrayList<ArrayList<String>> left, ArrayList<ArrayList<String>> right)
  {
        ArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();

        for(ArrayList<String> leftCursor : left)
        {
          for(ArrayList<String> rightCursor : right)
          {
            ArrayList<String> temp = new ArrayList<String>(leftCursor);
            temp.addAll(rightCursor);
                result.add(temp);
          }
        }

        return result;
  }

  static void printIter(String str, int count)
  {
        for(int i=0;i<count;i++)
        {
          System.out.print(str);
        }

  }

///////////////// Query rules ////////////////

/*

<COMMAND> ::= <QUERY LIST>
| exit <SEMICOLON>
<QUERY LIST> ::= (<QUERY> <SEMICOLON>)+
<QUERY> ::= <CREATE TABLE QUERY>
| <DROP TABLE QUERY>
| <DESC QUERY>
| <SELECT QUERY>
| <INSERT QUERY>
| <DELETE QUERY>
| <SHOW TABLES QUERY>
<SEMICOLON> ::= ;

*/
  static final public void command() throws ParseException, Exception {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE:
    case DROP:
    case DESC:
    case SHOW:
    case SELECT:
    case INSERT:
    case DELETE:
      queryList();
      break;
    case EXIT:
      jj_consume_token(EXIT);
      jj_consume_token(SEMICOLON);
      /* CLOSING DB */
          if (cursor != null) cursor.close();
          if (myDatabase != null) myDatabase.close();
          if (myDatabase != null) myClassDb.close();
          if (myDbEnvironment != null) myDbEnvironment.close();

      System.exit(0);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void queryList() throws ParseException, Exception {
  int q;
    label_1:
    while (true) {
      q = query();
      printMessage(q);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CREATE:
      case DROP:
      case DESC:
      case SHOW:
      case SELECT:
      case INSERT:
      case DELETE:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
  }

  static final public int query() throws ParseException, Exception {
  int q;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE:
      createTableQuery();
        q = PRINT_CREATE_TABLE;
      break;
    case DROP:
      dropTableQuery();
            q = PRINT_DROP_TABLE;
      break;
    case DESC:
      descQuery();
            q = PRINT_DESC;
      break;
    case SHOW:
      showTablesQuery();
            q = PRINT_SHOW_TABLES;
      break;
    case SELECT:
      selectQuery();
            q = PRINT_SELECT;
      break;
    case INSERT:
      insertQuery();
            q = PRINT_INSERT;
      break;
    case DELETE:
      deleteQuery();
            q = PRINT_DELETE;
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return q;}
    throw new Error("Missing return statement in function");
  }

/////////// delete rules ///////////
/*

<DELETE QUERY> ::= delete from <TABLE NAME> [<WHERE CLAUSE>]

*/
  static final public void deleteQuery() throws ParseException, Exception {
  String keyString;
  Table retrievedTable=null;
  ArrayList<String> boolTestResults=null;
  int succCount =0;
  int failCount =0;
    jj_consume_token(DELETE);
    jj_consume_token(FROM);
    keyString = tableName();
        // get table object from db
    DatabaseEntry theKey = null;
        try {
                theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
        }
    DatabaseEntry theData = new DatabaseEntry();
    if(!getTableFromDB(theKey, theData)) // not found
    {
      {if (true) throw new Exception("No such table");}
    }
    else // found
    {
      currFromTables = new ArrayList<String>();
      currFromTables.add(keyString);
      currOriginalNames = new ArrayList<String>(currFromTables);
          retrievedTable = (Table) entryBinding.entryToObject(theData);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      boolTestResults = whereClause(retrievedTable.getRecords());
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
        // constraints 확인


        // booltestResults 보면서 언노운 빼주고 트루인애들만 남기기
        if(boolTestResults == null)
          boolTestResults = new ArrayList<String>(Collections.nCopies(retrievedTable.getRecords().size(), "true"));
        ArrayList<ArrayList<String>> retrievedRecords = retrievedTable.getRecords();
        ArrayList<ArrayList<String>> newRecords = new ArrayList<ArrayList<String>>();
        for(int i=0;i<retrievedRecords.size();i++)
        {
          if(!boolTestResults.get(i).equals("true")) // true 이면 지우고 false거나 unknown이면 살린다
            newRecords.add(retrievedRecords.get(i));
          else
          {
            // 지워도 되는지 : 1. 이걸 레코드를 쪼는 레코드가 없거나 2. 이걸 쪼는 레코드가 있는데 nullable일때
                if(retrievedTable.canBeDeleted(retrievedRecords.get(i))) // retrievedRecords.get(i)얘를 지워도 되는지 안되는지 확인 
                {
                  succCount++; // 지워도 되면 지우고
                  retrievedTable.makeReferencingRecordsNull(retrievedRecords.get(i));
                }
                else // 지울수 없으면
                {
                  newRecords.add(retrievedRecords.get(i)); // 살리고
                  failCount++; // 카운트 업
                }
          }
        }

        //retrievedTable에 whereClause 결과로 나온 레코드 셋 교체 해주면 됨
        retrievedTable.setRecord(newRecords);
        entryBinding.objectToEntry(retrievedTable,theData);
        myDatabase.put(null, theKey, theData); // overwrite updated record
        myDatabase.sync();

        System.out.println(Integer.toString(succCount)+" row(s) are deleted");
        if(failCount > 0)
                System.out.println(Integer.toString(failCount)+" row(s) are not deleted due to referential integrity");
        {if (true) return;}
  }

/////////// insert rules ////////////////
/*

<INSERT QUERY> ::= insert into <TABLE NAME> <INSERT COLUMNS AND SOURCE>
<INSERT COLUMNS AND SOURCE> ::= [<COLUMN NAME LIST>] <VALUE LIST>
<VALUE LIST> ::= values <LEFT PAREN> <VALUE> (<COMMA> <VALUE>)* <RIGHT PAREN>
<VALUE> ::= null
| <COMPARABLE VALUE>

*/
  static final public void insertQuery() throws ParseException {
  String keyString;
  Pair<ArrayList<String>, ArrayList<String>> colsAndVals;
    jj_consume_token(INSERT);
    jj_consume_token(INTO);
    keyString = tableName();
    colsAndVals = insertColumnsAndSource();
    jj_consume_token(SEMICOLON);
        // get table object from db
    DatabaseEntry theKey = null;
        try {
                theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
        }
        ArrayList<String> queryColNames = colsAndVals.getLeft();
        ArrayList<String> queryValues = colsAndVals.getRight();

    DatabaseEntry theData = new DatabaseEntry();
    if(!getTableFromDB(theKey, theData)) // not found
    {
      System.out.println("No such table");
      {if (true) return;}
    }
    else // found
    {
      /* 에러 케이스
      	타입이 맞지 않을때.
      	컬럼과 값의 수나 타입이 맞지 않는 경우,
       	컬럼을 명시하지 않았을 때 값의 수가 해당 테이블의 attribute 수와 같지 않은 경우에도 이 에러에 해당됨
       */
          Table retrievedTable = (Table) entryBinding.entryToObject(theData);
          ArrayList<Attribute> definedAttrs = retrievedTable.getAttrs();

          ArrayList<String> resultRecord;
          ArrayList<Pair<String,String >> beforeSorting = new ArrayList<Pair<String,String >>();

// 쿼리에 컬럼 네임을 줬고,
          if(queryColNames != null)
          {
            // 쿼리 컬럼과 값의 수가 맞지 않을때
                if(queryColNames.size() != queryValues.size())
                {
              System.out.println("Insertion has failed: Types are not matched");
              {if (true) return;}
            }
            if(checkDup(queryColNames)) // 쿼리 col name이 중복된 쿼리
            {
              System.out.println("Insertion has failed: Types are not matched");
              {if (true) return;}
            }
            if(queryColNames.size() != definedAttrs.size()) // db에 정의된 컬럼 수랑 쿼리 컬럼 수 비교
            {
              System.out.println("Insertion has failed: Types are not matched");
              {if (true) return;}
            }

                // 존재하지 않는 컬럼에 값을 삽입하려고 할 경우 	    
                // 컬럼과 값의 타입이 맞지 않응때
                int i = 0;
                for(String cursor : queryColNames)
                {
                  Attribute foundAttr = retrievedTable.getAttributeByName(cursor);
                  if(foundAttr == null) // 쿼리 컬럼이 정의 안돼있을때
                  {
                    System.out.println("Insertion has failed: '"+cursor+"' does not exist");
                    {if (true) return;}
                  }
                  String currQueryVal = queryValues.get(i); // int@123151 , char@'sdfsdf', null@null
                  String queryValType = currQueryVal.split("@",2)[0];
                  String queryVal = currQueryVal.split("@",2)[1];
                  Boolean nullable = foundAttr.getNullable();

                  if(!foundAttr.getType().equals(queryValType)) // type이 맞지 않으면
                  {
                    if(queryValType.equals("null"))
                    { }
                        else if(!(foundAttr.getType().startsWith("char") && queryValType.equals("char")))
                        {
                          System.out.println("Insertion has failed: Types are not matched");
                  {if (true) return;}
                        }
                  }

                  if(queryVal.equals("null") && (!nullable)) // nullable 하지 않은 컬럼에 null 넣으면
                  {
                        System.out.println("Insertion has failed: '"+cursor+"' is not nullable");
                {if (true) return;}
                  }

                  // char 자르기
                  if(queryValType.equals("char"))
                  {
                    int size = Integer.parseInt(foundAttr.getType().substring(5,foundAttr.getType().length()-1));
                        queryVal = removeQuote(queryVal); // ' 없에기
                        if(queryVal.length() > size)
                          queryVal = queryVal.substring(0,size);
                  }

                  // 실제 테이블의 컬럼 인덱스와 쿼리받은 벨류 페어로 일단 저장 후 나중에 실제 테이블 컬럼 순으로 벨류 정렬
                  beforeSorting.add(new Pair<String,String>(Integer.toString(definedAttrs.indexOf(foundAttr)),queryVal));

                  i++;
                }
          }
// 쿼리에 컬럼 네임을 안줬고,
          else
          {
                if(queryValues.size() != definedAttrs.size()) // db에 정의된 컬럼 수랑 쿼리 컬럼 수 비교
            {
              System.out.println("Insertion has failed: Types are not matched");
              {if (true) return;}
            }

                // 존재하지 않는 컬럼에 값을 삽입하려고 할 경우 	    
                // 컬럼과 값의 타입이 맞지 않응때
                int i = 0;
                for(Attribute cursor : definedAttrs)
                {
                  String currQueryVal = queryValues.get(i); // int@123151 , char@'sdfsdf', null@null
                  String queryValType = currQueryVal.split("@",2)[0];
                  String queryVal = currQueryVal.split("@",2)[1];
                  Boolean nullable = cursor.getNullable();

                  if(!cursor.getType().equals(queryValType)) // type이 맞지 않으면
                  {
                    if(queryValType.equals("null"))
                    { }
                        else if(!(cursor.getType().startsWith("char") && queryValType.equals("char")))
                        {
                          System.out.println("Insertion has failed: Types are not matched");
                  {if (true) return;}
                        }
                  }

                  if(queryVal.equals("null") && (!nullable)) // nullable 하지 않은 컬럼에 null 넣으면
                  {
                        System.out.println("Insertion has failed: '"+cursor.getAttrName()+"' is not nullable");
                {if (true) return;}
                  }

                  // char 자르기
                  if(queryValType.equals("char"))
                  {
                    int size = Integer.parseInt(cursor.getType().substring(5,cursor.getType().length()-1));
                        queryVal = removeQuote(queryVal); // ' 없에기
                        if(queryVal.length() > size)
                          queryVal = queryVal.substring(0,size);
                  }

                  // 실제 테이블의 컬럼 인덱스와 쿼리받은 벨류 페어로 일단 저장 후 나중에 실제 테이블 컬럼 순으로 벨류 정렬
                  beforeSorting.add(new Pair<String,String>(Integer.toString(i),queryVal));

                  i++;
                }

          }

 // 정렬해서 record에 넣어주기
          resultRecord = new ArrayList<String>(Collections.nCopies(beforeSorting.size(), ""));
          for(Pair<String,String> cursor : beforeSorting)
          {
            resultRecord.set(Integer.parseInt(cursor.getLeft()),cursor.getRight());
          }
//primary key 제약에 위배된다면
          if(!retrievedTable.checkPrimaryConstraint(resultRecord))
          {
            System.out.println("Insertion has failed: Primary key duplication");
            {if (true) return;}
          }
//결과가 foreign key 제약에 위배된다면 : foreign key 하나씩 돌면서 foreign key attr 인덱스 표시하고 해당 테이블의 레코드 가져와서
// 그 테이블의 foreign key attr 표시해서 쭉 비교
          if(!retrievedTable.checkForeignConstraint(resultRecord))
          {
                System.out.println("Insertion has failed: Referential integrity violation");
            {if (true) return;}
          }
          ArrayList<ArrayList<String>> retrievedRecords = retrievedTable.getRecords();
          retrievedRecords.add(resultRecord);
          retrievedTable.setRecord(retrievedRecords);

          entryBinding.objectToEntry(retrievedTable,theData);
          myDatabase.put(null, theKey, theData); // overwrite updated record
          myDatabase.sync();

          System.out.println("The row is inserted");
          {if (true) return;}
    }
  }

  static final public Pair<ArrayList<String>, ArrayList<String>> insertColumnsAndSource() throws ParseException {
  ArrayList<String> valList;
  ArrayList<String> colNameList=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      colNameList = columnNameList();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    valList = valueList();
        {if (true) return (new Pair<ArrayList<String>, ArrayList<String>>(colNameList, valList));}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> valueList() throws ParseException {
  ArrayList<String> result = new ArrayList<String>();
  String val;
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    val = value();
        result.add(val);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      val = value();
          result.add(val);
    }
    jj_consume_token(RIGHT_PAREN);
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public String value() throws ParseException {
  String result;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      jj_consume_token(NULL);
        {if (true) return "null@null";}
      break;
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      result = comparableValue();
        {if (true) return result;}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/////////// select rules /////////////////
/*

<SELECT QUERY> ::= select <SELECT LIST> <TABLE EXPRESSION>
<SELECT LIST> ::= *
| <SELECTED COLUMN> (<COMMA> <SELECTED COLUMN>)*
<SELECTED COLUMN> ::= [<TABLE NAME> <PERIOD>] <COLUMN NAME> [as <COLUMN NAME>]
<PERIOD> ::= .
<TABLE EXPRESSION> ::= <FROM CLAUSE> [<WHERE CLAUSE>]
<FROM CLAUSE> ::= from <TABLE REFERENCE LIST>
<TABLE REFERENCE LIST> ::= <REFERED TABLE> (<COMMA> <REFERED TABLE>)*
<REFERED TABLE> ::= <TABLE NAME> [as <TABLE NAME>]
<WHERE CLAUSE> ::= where <BOOLEAN VALUE EXPRESSION>
<BOOLEAN VALUE EXPRESSION> ::= <BOOLEAN TERM> ( or <BOOLEAN TERM>)*
<BOOLEAN TERM> ::= <BOOLEAN FACTOR>( and <BOOLEAN FACTOR> )*
<BOOLEAN FACTOR> ::= [not] <BOOLEAN TEST>
<BOOLEAN TEST> ::= <PREDICATE>
| <PARENTHESIZED BOOLEAN EXPRESSION>
<PARENTHESIZED BOOLEAN EXPRESSION> ::= <LEFT PAREN> <BOOLEAN VALUE EXPRESSION> <RIGHT PAREN>
<PREDICATE> ::= <COMPARISON PREDICATE>
| <NULL PREDICTE>
<COMPARISON PREDICATE> ::= <COMP OPERAND> <COMP OP> <COMP OPERAND>
<COMP OPERAND> ::= <COMPARABLE VALUE>
| [<TABLE NAME> <PERIOD>] <COLUMN NAME>
<COMP OP> ::= < | > | = | >= | <= | !=
<COMPARABLE VALUE> ::= <INT VALUE>
| <CHAR STRING>
| <DATE VALUE>
<NULL PREDICATE> ::= [<TABLE NAME> <PERIOD>] <COLUMN NAME> <NULL OPERATION>
<NULL OPERATION> ::= is [not] null

*/
  static final public void selectQuery() throws ParseException, Exception {
  ArrayList<String> selectedColList;
  ArrayList<ArrayList<String>> filteredRecords;
    jj_consume_token(SELECT);
    selectedColList = selectList();
    // from절로 넘어가기 전에 이거 초기화
        currFromTables = new ArrayList<String>();
    currOriginalNames = new ArrayList<String>();
    filteredRecords = tableExpression();
    jj_consume_token(SEMICOLON);
        // selectedColList 체크 - > empty면 *임, 각 colname 형식은 tablename@colname@newcolname
        // tablename.col as rename 
        // 모호함 체크
        ArrayList<Pair<String,Integer>> printColNameAndIndex = new ArrayList<Pair<String,Integer>>();
        if(selectedColList.isEmpty()) // * 일때 : 안모호함
        {
                // 출력할 컬럼들을 모든 컬럼들로
          int i = 0;
          for(String cursor : currOriginalNames)
          {
             // get table object from db
                DatabaseEntry theKey = null;
                try {
                        theKey = new DatabaseEntry(cursor.getBytes("UTF-8"));
                } catch (UnsupportedEncodingException e) {e.printStackTrace();}
                DatabaseEntry theData = new DatabaseEntry();
                if(!getTableFromDB(theKey, theData)) // not found
                {
                  System.out.println("select : can not reach here");
                }
                else // found
                {
                  Table retrievedTable = (Table) entryBinding.entryToObject(theData);
                  for(Attribute attrCursor : retrievedTable.getAttrs())
                  {
                        printColNameAndIndex.add(new Pair<String,Integer>(attrCursor.getAttrName(),i));
                        i++;
                  }
                }
          }
        }
        else
        {

          for(String cursor : selectedColList)
          {
            String[] parsedCursor = cursor.split("@");
            String tableName = parsedCursor[0];
            String colName = parsedCursor[1];
            String newColName = parsedCursor[2];
            Integer fromIndex = 0;

            if(tableName.equals("")) // 테이블 네임 명시 안했을때
            {
              Boolean checkAm = false;
              int i = 0;
              for(String fromCursor : currOriginalNames)
              {
                         // get table object from db
                    DatabaseEntry theKey = null;
                        try {
                                theKey = new DatabaseEntry(fromCursor.getBytes("UTF-8"));
                        } catch (UnsupportedEncodingException e) {
                                e.printStackTrace();
                        }
                    DatabaseEntry theData = new DatabaseEntry();
                    if(!getTableFromDB(theKey, theData)) // not found
                    {
                      System.out.println("select : can not reach here");
                    }
                    else // found
                    {
                      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
                      if(retrievedTable.containsAttr(colName))
                      {
                                if(checkAm) // 이미 한번 나왔었다면
                                {
                                  {if (true) throw new Exception("Selection has failed: fail to resolve '"+colName+"'");}
                                }
                                checkAm = true;
                                fromIndex = i;
                      }
                    }
                    i++;
              }
              if(!checkAm) // 다 돌동안 한번도 안나왔다면
              {
                    {if (true) throw new Exception("Selection has failed: fail to resolve '"+colName+"'");}
              }
              // 모호하지 않다
            }
            else // 테이블네임 명시했을때
            {
                  Boolean checkAm = false;
                  int j=0;
              for(String fromCursor : currFromTables)
              {
                if(fromCursor.equalsIgnoreCase(tableName))
                {
                  if(checkAm) // from절에 같은이름 두개이상있을때
                  {
                                {if (true) throw new Exception("Selection has failed: fail to resolve '"+colName+"'");}
                  }
                  checkAm = true;
                  fromIndex = j;
                }
                j++;
              }
              if(!checkAm) // 테이블네임이 프롬절에 없다
              {
                    {if (true) throw new Exception("Selection has failed: fail to resolve '"+colName+"'");}
              }
               // get table object from db
                  DatabaseEntry theKey = null;
                  try {
                                theKey = new DatabaseEntry(currOriginalNames.get(fromIndex).getBytes("UTF-8"));
                  } catch (UnsupportedEncodingException e) {e.printStackTrace();}
                  DatabaseEntry theData = new DatabaseEntry();
                  if(!getTableFromDB(theKey, theData)) // not found
                  {
                    System.out.println("select : can not reach here");
                  }
                  else // found
                  {
                    Table retrievedTable = (Table) entryBinding.entryToObject(theData);
                    if(!retrievedTable.containsAttr(colName)) // 해당 테이블이 컬럼을 포함 안하면
                    {
                          {if (true) throw new Exception("Selection has failed: fail to resolve '"+colName+"'");}
                    }
                  }

            }
            // 모호하지 않다
            // 여기서 페어 만들어야함
            if(newColName.equals("null"))
              printColNameAndIndex.add(new Pair<String,Integer>(colName,getColIndexAndType(fromIndex,colName).getLeft()));
                else
              printColNameAndIndex.add(new Pair<String,Integer>(newColName,getColIndexAndType(fromIndex,colName).getLeft()));
          }

        }
        // 여기서 출력하자

//+----------------+-------------+---------+
//| ACCOUNT_NUMBER | BRANCH_NAME | BALANCE |
//+----------------+-------------+---------+
//| A-101          | Downtown    | 500     |

    for(Pair<String,Integer> cursor : printColNameAndIndex)
    {
          System.out.print("+");
          printIter("-",cursor.getLeft().length()+12);
    }
    System.out.println("+");

    for(Pair<String,Integer> cursor : printColNameAndIndex)
    {
          System.out.print("|");
          printIter(" ",6);
          System.out.print(cursor.getLeft().toUpperCase());
          printIter(" ",6);
    }
    System.out.println("|");

    for(Pair<String,Integer> cursor : printColNameAndIndex)
    {
          System.out.print("+");
          printIter("-",cursor.getLeft().length()+12);
    }
    System.out.println("+");

    Boolean temp=false;
    for(ArrayList<String> recCursor : filteredRecords)
    {
          for(Pair<String,Integer> cursor : printColNameAndIndex)
      {
            System.out.print("|");
            printIter(" ",1);
            System.out.print(recCursor.get(cursor.getRight()));
            printIter(" ",11+(cursor.getLeft().length()-recCursor.get(cursor.getRight()).length()));
      }
      System.out.println("|");
      temp = true;
    }
    if(temp)
    {
      for(Pair<String,Integer> cursor : printColNameAndIndex)
      {
            System.out.print("+");
            printIter("-",cursor.getLeft().length()+12);
      }
      System.out.println("+");
    }
  }

  static final public ArrayList<String> selectList() throws ParseException, Exception {
  ArrayList<String> result = new ArrayList<String>();
  String temp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
      jj_consume_token(ASTERISK);
        {if (true) return result;}
      break;
    case LEGAL_IDENTIFIER:
      temp = selectedColumn();
          result.add(temp);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_3;
        }
        jj_consume_token(COMMA);
        temp = selectedColumn();
                result.add(temp);
      }
        {if (true) return result;}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String selectedColumn() throws ParseException, Exception {
  String tableName = "";
  String rename = "null";
  String colName = "";
    if (jj_2_1(2)) {
      //#7 choice confilict, <LEGAL_IDENTIFIER>.... using LOOKAHEAD, solve this.
          tableName = tableName();
      jj_consume_token(PERIOD);
    } else {
      ;
    }
    colName = columnName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      rename = columnName();
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
        {if (true) return tableName+"@"+colName+"@"+rename;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<ArrayList<String>> tableExpression() throws ParseException, Exception {
  ArrayList<ArrayList<String>> productedRecords;
  ArrayList<String> boolTestResults=null;
    productedRecords = fromClause();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      boolTestResults = whereClause(productedRecords);
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
        if(boolTestResults == null) // where절이 없으면
          boolTestResults = new ArrayList<String>(Collections.nCopies(productedRecords.size(), "true"));

        ArrayList<ArrayList<String>> newRecords = new ArrayList<ArrayList<String>>();
        for(int i=0;i<productedRecords.size();i++)
        {
          if(boolTestResults.get(i).equals("true")) // true 이면 남긴다
            newRecords.add(productedRecords.get(i));
        }
        // 여기서 정리 조져서 리턴
        {if (true) return newRecords;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<ArrayList<String>> fromClause() throws ParseException, Exception {
  ArrayList<ArrayList<String>> result;
    jj_consume_token(FROM);
    result = tableReferenceList();
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<ArrayList<String>> tableReferenceList() throws ParseException, Exception {
  ArrayList<ArrayList<String>> result;
  ArrayList<ArrayList<String>> additional;
    result = referedTable();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      additional = referedTable();
          result = carteProduct(result, additional);
    }
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<ArrayList<String>> referedTable() throws ParseException, Exception {
  String keyString;
  String newName;
  ArrayList<ArrayList<String>> result;
    keyString = tableName();
                // get table object from db
            DatabaseEntry theKey = null;
                try {
                        theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
                } catch (UnsupportedEncodingException e) {
                        e.printStackTrace();
                }
            DatabaseEntry theData = new DatabaseEntry();
            if(!getTableFromDB(theKey, theData))// not found
                {if (true) throw new Exception("Selection has failed: '"+keyString+"' does not exist");}
            else // found
                {
                  Table retrievedTable = (Table) entryBinding.entryToObject(theData);
                  result = retrievedTable.getRecords();
                // select 쿼리함수에서 currFromTables랑 currOriginalNames를 그냥 할당하고
                // 여기서 add 하는식으로?
                  currFromTables.add(keyString);
                  currOriginalNames.add(keyString);
                }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      newName = tableName();
                  currFromTables.set(currFromTables.size()-1,newName);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
          {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> whereClause(ArrayList<ArrayList<String>> records) throws ParseException, Exception {
  ArrayList<String> result;
    jj_consume_token(WHERE);
    result = booleanValueExpression(records);
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> booleanValueExpression(ArrayList<ArrayList<String>> records) throws ParseException, Exception {
  ArrayList<String> result,additional;
    result = booleanTerm(records);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_5;
      }
      jj_consume_token(OR);
      additional = booleanTerm(records);
      for(int i=0;i<result.size();i++)
      {
        if(result.get(i).equals("unknown"))
        {
          if(additional.get(i).equals("true"))
            result.set(i,"true");
          else
            result.set(i,"unknown");
        }
        else if(additional.get(i).equals("unknown"))
        {
          if(result.get(i).equals("true"))
            result.set(i,"true");
          else
                    result.set(i,"unknown");
        }
        else
          result.set(i,String.valueOf(Boolean.valueOf(result.get(i)) || Boolean.valueOf(additional.get(i)))); // 둘 다 언노운이 아니면
          }
    }
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> booleanTerm(ArrayList<ArrayList<String>> records) throws ParseException, Exception {
  ArrayList<String> result,additional;
    result = booleanFactor(records);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_6;
      }
      jj_consume_token(AND);
      additional = booleanFactor(records);
            for(int i=0;i<result.size();i++)
            {
                if(result.get(i).equals("unknown"))
                {
                  if(additional.get(i).equals("false"))
                    result.set(i,"false");
                  else
                    result.set(i,"unknown");
                }
                else if(additional.get(i).equals("unknown"))
                {
                  if(result.get(i).equals("false"))
                    result.set(i,"false");
                  else
                            result.set(i,"unknown");
                }
                else
                  result.set(i,String.valueOf(Boolean.valueOf(result.get(i)) && Boolean.valueOf(additional.get(i)))); // 둘 다 언노운이 아니면
                }
    }
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> booleanFactor(ArrayList<ArrayList<String>> records) throws ParseException, Exception {
  ArrayList<String> result;
  Boolean isNot = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      isNot = true;
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    result = booleanTest(records);
    for(int i=0;i<result.size();i++)
    {
          if(isNot)
          {
            if(!result.get(i).equals("unknown"))
              result.set(i,String.valueOf(!Boolean.valueOf(result.get(i))));
          }
        }
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> booleanTest(ArrayList<ArrayList<String>> records) throws ParseException, Exception {
  ArrayList<String> result;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case LEGAL_IDENTIFIER:
    case CHAR_STRING:
    case DATE_VALUE:
      result = predicate(records);
      break;
    case LEFT_PAREN:
      result = parenthesizedBooleanExpression(records);
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> parenthesizedBooleanExpression(ArrayList<ArrayList<String>> records) throws ParseException, Exception {
  ArrayList<String> result;
    jj_consume_token(LEFT_PAREN);
    result = booleanValueExpression(records);
    jj_consume_token(RIGHT_PAREN);
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> predicate(ArrayList<ArrayList<String>> records) throws ParseException, Exception {
  ArrayList<String> result;
    if (jj_2_2(4)) {
      // #8 choice conflict <LEGAL_IDENTIFIER> <PERIOD> ... , to solve this, use LOOKAHEAD(3)
          result = comparisonPredicate(records);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEGAL_IDENTIFIER:
        result = nullPredicate(records);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> comparisonPredicate(ArrayList<ArrayList<String>> records) throws ParseException, Exception {
  String leftOperand,rightOperand,op;
  String boolTemp;
  ArrayList<String> result = new ArrayList<String>(Collections.nCopies(records.size(),""));
    leftOperand = compOperand();
    // "tableindex@col name" or "type@value"
      op = compOp();
    //  "<" | ">" | "=" | "<=" | ">=" | "!=" 
      rightOperand = compOperand();
        String leftType = leftOperand.split("@",2)[0];
        String leftVal = leftOperand.split("@",2)[1];
        String rightType = rightOperand.split("@",2)[0];
        String rightVal = rightOperand.split("@",2)[1];
        if(leftType.equals("char"))
          leftVal = removeQuote(leftVal);
        if(rightType.equals("char"))
          rightVal = removeQuote(rightVal);

        if(isType(leftType) && isType(rightType)) // 상수비교 명제
        {
          // 두 상수의 타입이 같을때
          if(leftType.equals(rightType))
          {
                boolTemp = compareTwoValues(leftVal,op,rightVal,leftType.equals("int")); // 명제가 참이면 항상 참(상수)
                for(int i=0;i<result.size();i++)
                {
                  result.set(i,boolTemp);
                }
                {if (true) return result;}
          }
          else // 두 상수의 타입이 다를 때
          {
            {if (true) throw new Exception("Where clause try to compare incomparable values");}
          }
        }
        else if(isType(rightType)) // 왼쪽 변수 오른쪽 상수 , leftType : table index, left Val : col name
        {
          Pair<Integer, String> leftIndexAndType = getColIndexAndType(Integer.parseInt(leftType),leftVal);
          if(leftIndexAndType.getRight().startsWith(rightType)) // 둘의 타입이 같다면
          {
            for(int i=0;i<result.size();i++)
            {
                  result.set(i,compareTwoValues(records.get(i).get(leftIndexAndType.getLeft()),op,rightVal,rightType.equals("int")));
            }
                {if (true) return result;}
          }
          else// 타입이 다르다면
          {
            {if (true) throw new Exception("Where clause try to compare incomparable values");}
          }
        }
        else if(isType(leftType)) // 왼쪽 상수 오른쪽 변수
        {
          Pair<Integer, String> rightIndexAndType = getColIndexAndType(Integer.parseInt(rightType),rightVal);
          if(rightIndexAndType.getRight().startsWith(leftType)) // 둘의 타입이 같다면
          {
            for(int i=0;i<result.size();i++)
            {
                  result.set(i,compareTwoValues(leftVal,op,records.get(i).get(rightIndexAndType.getLeft()),leftType.equals("int")));
                }
                {if (true) return result;}
          }
          else// 타입이 다르다면
          {
            {if (true) throw new Exception("Where clause try to compare incomparable values");}
          }
        }
        else // 둘다 변수
        {
          Pair<Integer, String> leftIndexAndType = getColIndexAndType(Integer.parseInt(leftType),leftVal);
          Pair<Integer, String> rightIndexAndType = getColIndexAndType(Integer.parseInt(rightType),rightVal);
          if(rightIndexAndType.getRight().equals(leftIndexAndType.getRight())
                || (rightIndexAndType.getRight().startsWith("char") && leftIndexAndType.getRight().startsWith("char"))) // 둘의 타입이 같다면
          {
            for(int i=0;i<result.size();i++)
            {
                  result.set(i,compareTwoValues(records.get(i).get(leftIndexAndType.getLeft()),op,records.get(i).get(rightIndexAndType.getLeft()),leftIndexAndType.getRight().equals("int")));
                }
                {if (true) return result;}
          }
          else// 타입이 다르다면
          {
            {if (true) throw new Exception("Where clause try to compare incomparable values");}
          }
        }
    throw new Error("Missing return statement in function");
  }

  static final public String compOperand() throws ParseException, Exception {
  String result, queryTableName = "";
  Boolean temp = false;
  int index = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      result = comparableValue();
        {if (true) return result;}
      break;
    case LEGAL_IDENTIFIER:
      if (jj_2_3(2)) {
        //#7
              queryTableName = tableName();
        jj_consume_token(PERIOD);
          if(!containsCaseInsen(currFromTables, queryTableName))// from clause does not contains
                  {
                  {if (true) throw new Exception("Where clause try to reference tables which are not specified");}
                  }
      } else {
        ;
      }
      result = columnName();
          if(queryTableName.equals("")) // 쿼리에서 테이블 네임 명시 안했을때
          {
            int i = 0;
                for(String tableNameCursor : currOriginalNames) // 프롬절 테이블들 다 돌면서 있는지 확인, 모호한지 확인
                {
                  // get table object from db
                    DatabaseEntry theKey = null;
                        try {
                                theKey = new DatabaseEntry(tableNameCursor.getBytes("UTF-8"));
                        } catch (UnsupportedEncodingException e) {
                                e.printStackTrace();
                        }
                    DatabaseEntry theData = new DatabaseEntry();
                    if(!getTableFromDB(theKey, theData)) // not found
                    {
                      System.out.println("compOperand : can not reach here");
                    }
                    else // found
                    {
                      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
                      if(retrievedTable.containsAttr(result))
                      {
                                if(temp) // 이미 다른 테이블에 이 컬럼과 같은 이름이 존재 : 모호함
                                {
                                        {if (true) throw new Exception("Where clause contains ambiguous reference");}
                                }
                                else
                                {
                                  temp = true;
                                  index = i;
                                }
                      }
                        }
                        i++;
                }
                if(!temp) // 이 컬럼을 포함하는 테이블이 하나도 없으면
                {
                        {if (true) throw new Exception("Where clause try to reference non existing column");}
                }
          }
          else // 쿼리에서 테이블 네임 명시 했을때
          {
            // 명시한 테이블의 attrs중에 이 콜롬네임이 있는지 확인
                // 모호함 확인
                Boolean checkAm = false;
                int i=0;
                for(String cursor : currFromTables)
                {
                  if(cursor.equalsIgnoreCase(queryTableName))
                  {
                        if(checkAm) // from절에 같은 테이블 이름 존재
                        {
                                        {if (true) throw new Exception("Where clause contains ambiguous reference");}
                        }
                        checkAm = true;
                        index = i;
                  }
                  i++;
                }

            // get table object from db
            DatabaseEntry theKey = null;
                try {
                        theKey = new DatabaseEntry(currOriginalNames.get(index).getBytes("UTF-8"));
                } catch (UnsupportedEncodingException e) {
                        e.printStackTrace();
                }
            DatabaseEntry theData = new DatabaseEntry();
            if(!getTableFromDB(theKey, theData)) // not found
            {
              System.out.println("compOperand : can not reach here");
            }
            else // found
            {
              Table retrievedTable = (Table) entryBinding.entryToObject(theData);
              if(!retrievedTable.containsAttr(result)) // 명시한 테이블이 이 컬럼을 포함 안하면
              {
                        {if (true) throw new Exception("Where clause try to reference non existing column");}
              }
                }
          }

          queryTableName = Integer.toString(index) + "@";
        {if (true) return queryTableName + result;} // "tab index"+"@"+"colname"

      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String compOp() throws ParseException {
  Token signs;
    signs = jj_consume_token(COMPARISON_SIGNS);
        {if (true) return signs.image;}
    throw new Error("Missing return statement in function");
  }

  static final public String comparableValue() throws ParseException {
  Token result;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
      result = jj_consume_token(INT_VALUE);
        {if (true) return "int@"+result.image;}
      break;
    case CHAR_STRING:
      result = jj_consume_token(CHAR_STRING);
        {if (true) return "char@"+result.image;}
      break;
    case DATE_VALUE:
      result = jj_consume_token(DATE_VALUE);
        {if (true) return "date@"+result.image;}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> nullPredicate(ArrayList<ArrayList<String>> records) throws ParseException, Exception {
  String result, queryTableName = "";
  ArrayList<String> boolResults = new ArrayList<String>(Collections.nCopies(records.size(),""));
  Boolean temp = false;
  Boolean isNot = false;
  int index = 0;
    if (jj_2_4(2)) {
      //#7
              queryTableName = tableName();
      jj_consume_token(PERIOD);
      if(!containsCaseInsen(currFromTables, queryTableName))// from clause does not contains
          {
            {if (true) throw new Exception("Where clause try to reference tables which are not specified");}
          }
    } else {
      ;
    }
    result = columnName();
          if(queryTableName.equals("")) // 쿼리에서 테이블 네임 명시 안했을때
          {
            int i = 0;
                for(String tableNameCursor : currOriginalNames) // 프롬절 테이블들 다 돌면서 있는지 확인, 모호한지 확인
                {
                  // get table object from db
                    DatabaseEntry theKey = null;
                        try {
                                theKey = new DatabaseEntry(tableNameCursor.getBytes("UTF-8"));
                        } catch (UnsupportedEncodingException e) {
                                e.printStackTrace();
                        }
                    DatabaseEntry theData = new DatabaseEntry();
                    if(!getTableFromDB(theKey, theData)) // not found
                    {
                      System.out.println("NullPredicate : can not reach here");
                    }
                    else // found
                    {
                      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
                      if(retrievedTable.containsAttr(result))
                      {
                                if(temp) // 이미 다른 테이블에 이 컬럼과 같은 이름이 존재 : 모호함
                                {
                                        {if (true) throw new Exception("Where clause contains ambiguous reference");}
                                }
                                else
                                {
                                  temp = true;
                                  index = i;
                                }
                      }
                        }
                        i++;
                }
                if(!temp) // 이 컬럼을 포함하는 테이블이 하나도 없으면
                {
                        {if (true) throw new Exception("Where clause try to reference non existing column");}
                }
          }
          else // 쿼리에서 테이블 네임 명시 했을때
          {
            // 명시한 테이블의 attrs중에 이 콜롬네임이 있는지 확인
                // 모호함 확인
                Boolean checkAm = false;
                int i=0;
                for(String cursor : currFromTables)
                {
                  if(cursor.equalsIgnoreCase(queryTableName))
                  {
                        if(checkAm) // from절에 같은 테이블 이름 존재
                        {
                                        {if (true) throw new Exception("Where clause contains ambiguous reference");}
                        }
                        checkAm = true;
                        index = i;
                  }
                  i++;
                }

            // get table object from db
            DatabaseEntry theKey = null;
                try {
                        theKey = new DatabaseEntry(currOriginalNames.get(index).getBytes("UTF-8"));
                } catch (UnsupportedEncodingException e) {
                        e.printStackTrace();
                }
            DatabaseEntry theData = new DatabaseEntry();
            if(!getTableFromDB(theKey, theData)) // not found
            {
              System.out.println("NullPredicate : can not reach here");
            }
            else // found
            {
              Table retrievedTable = (Table) entryBinding.entryToObject(theData);
              if(!retrievedTable.containsAttr(result)) // 명시한 테이블이 이 컬럼을 포함 안하면
              {
                        {if (true) throw new Exception("Where clause try to reference non existing column");}
              }
                }
          }

          queryTableName = Integer.toString(index) + "@";
          result = queryTableName + result;
    isNot = nullOperation();
 // result : "tableindex@col name""
                String tableIndex = result.split("@",2)[0];
                String colName = result.split("@",2)[1];

            Pair<Integer, String> indexAndType = getColIndexAndType(Integer.parseInt(tableIndex),colName);
                for(int i=0;i<boolResults.size();i++)
                {
                  if(isNot) // is not null 이면
                  {
                    if(!records.get(i).get(indexAndType.getLeft()).equals("null"))
                      boolResults.set(i,"true");
                    else
                      boolResults.set(i,"false");
                  }
                  else // is null 이면
                  {
                        if(records.get(i).get(indexAndType.getLeft()).equals("null"))
                          boolResults.set(i,"true");
                        else
                          boolResults.set(i,"false");
                  }
                }
                {if (true) return boolResults;}
    throw new Error("Missing return statement in function");
  }

  static final public Boolean nullOperation() throws ParseException {
  Boolean isNot;
    jj_consume_token(IS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT_NULL:
      jj_consume_token(NOT_NULL);
      isNot = true;
      break;
    case NULL:
      jj_consume_token(NULL);
      isNot = false;
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return isNot;}
    throw new Error("Missing return statement in function");
  }

/////////// show table rules ///////////
/*

<SHOW TABLES QUERY> ::= show tables

*/
  static final public void showTablesQuery() throws ParseException {
    jj_consume_token(SHOW);
    jj_consume_token(TABLES);
    jj_consume_token(SEMICOLON);
        /* PRJ2 #3 : implementation of show tables */

        if (cursor.getFirst(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.NOTFOUND)
        { // empty db case
          System.out.println("There is no table");
        }
        else
        {
          System.out.println("----------------");
          do // traverse entire db
          {
            String res_key = null;
            try {
                                res_key = new String(foundKey.getData(), "UTF-8");
                } catch (UnsupportedEncodingException e) {
                        e.printStackTrace();
                }
            System.out.println(res_key);
          } while (cursor.getNext(foundKey, foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);
          System.out.println("----------------");
        }
  }

/////////// desc rules ////////////
/*

<DESC QUERY> ::= desc <TABLE NAME>

*/
// PRJ2 #11 : implementation of desc
  static final public void descQuery() throws ParseException {
  String keyString;
    jj_consume_token(DESC);
    keyString = tableName();
    jj_consume_token(SEMICOLON);
    try {
    // get table object from db
    DatabaseEntry theKey = null;
        try {
                theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
        }
    DatabaseEntry theData = new DatabaseEntry();
    String attrName, attrType, attrNullable;
    if(!getTableFromDB(theKey, theData)) // not found
    {
      System.out.println("No such table");
    }
    else // found
    {
      // the EntryBinding created above
      Table retrievedTable = (Table) entryBinding.entryToObject(theData);

          System.out.println("-------------------------------------------------");
          System.out.println("table_name ["+retrievedTable.getTableName()+"]");
          System.out.printf("%-19s%-10s%-10s%-10s\u005cn", "column_name","type","null","key");

          for(Attribute cursor : retrievedTable.getAttrs())
          {
            attrName = cursor.getAttrName();
            attrType = cursor.getType();
            if(cursor.getNullable())
              attrNullable = "Y";
            else
              attrNullable = "N";
            System.out.printf("%-19s%-10s%-10s%-10s\u005cn", attrName, attrType, attrNullable, whatKey(retrievedTable, attrName));
          }

          System.out.println("-------------------------------------------------");
        }
        } catch (Exception e) { e.printStackTrace(); }
  }

/////////// drop table rules /////////////
/*

<DROP TABLE QUERY> ::= drop table <TABLE NAME>

*/

// PRJ2 #12 : implementation of drop table
  static final public void dropTableQuery() throws ParseException {
  String keyString;
    jj_consume_token(DROP);
    jj_consume_token(TABLE);
    keyString = tableName();
    jj_consume_token(SEMICOLON);
        // get table object from db
    DatabaseEntry theKey = null;
        try {
                theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
        }
    DatabaseEntry theData = new DatabaseEntry();
    if(!getTableFromDB(theKey, theData)) // not found
    {
      System.out.println("No such table");
    }
    else // found
    {
      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
          if(retrievedTable.isReferenced())
                System.out.println("Drop table has failed: '"+ keyString +"' is referenced by other table");
          else
          {
                deleteReference(retrievedTable); // delete this table from referencedBy list of other referenced table
                myDatabase.delete(null, theKey);
                myDatabase.sync();
                System.out.println("'"+ keyString +"' table is dropped");
          }
    }
  }

/////////// create table rules ///////////////
/*

<CREATE TABLE QUERY> ::= create table <TABLE NAME> <TABLE ELEMENT LIST>
<TABLE ELEMENT LIST> ::= <LEFT PAREN> <TABLE ELEMENT> (<COMMA> <TABLE ELEMENT>)* <RIGHT PAREN>
<TABLE ELEMENT> ::= <COLUMN DEFINITION>
| <TABLE CONSTRAINT DEFINITION>
<COLUMN DEFINITION> ::= <COLUMN NAME> <DATA TYPE> [not null]
<TABLE CONSTRAINT DEFINITION> ::= <PRIMARY KEY CONSTRAINT>
| <REFERENTIAL CONSTRAINT>
<PRIMARY KEY CONSTRAINT> ::= primary key <COLUMN NAME LIST>
<REFERENTIAL CONSTRAINT> ::= foreign key <COLUMN NAME LIST> references <TABLE NAME> <COLUMN NAME LIST>
<COLUMN NAME LIST> ::= <LEFT PAREN> <COLUMN NAME> (<COMMA> <COLUMN NAME>)* <RIGHT PAREN>
<DATA TYPE> ::= int
| char <LEFT PAREN> <INT VALUE> <RIGHT PAREN>
| date
<TABLE NAME> ::= <LEGAL IDENTIFIER>
<COLUMN NAME> ::= <LEGAL IDENTIFIER>
<LEGAL IDENTIFIERS> ::= <ALPHABET> (<ALPHABET> | <UNDERSCORE>)*
<UNDERSCORE> ::= _
<LEFT PAREN> ::= (
<RIGHT PAREN> ::= )
<COMMA> ::= ,

*/
  static final public void createTableQuery() throws ParseException {
  String tableNameString;
  TableElementList definitionList;
  Table newTable = new Table();
    jj_consume_token(CREATE);
    jj_consume_token(TABLE);
    tableNameString = tableName();
    definitionList = tableElementList();
    jj_consume_token(SEMICOLON);
    try {
        if(tableExist(tableNameString))
          {if (true) throw new Exception("Create table has failed: table with the same name already exists");}

        newTable.setTableName(tableNameString);
        newTable = makeColumns(newTable, definitionList);
        newTable = applyConstraints(newTable, definitionList);

        putObjectEntry(tableNameString,newTable);

        System.out.println("'"+ tableNameString +"' table is created");
        }
        catch (Exception e)
        {
                System.out.println(e.getMessage());
                SimpleDBMSParser.ReInit(System.in);
        }
  }

  static final public TableElementList tableElementList() throws ParseException {
  TableElementList definitionList = new TableElementList();
    jj_consume_token(LEFT_PAREN);
    definitionList = tableElement(definitionList);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_7;
      }
      jj_consume_token(COMMA);
      definitionList = tableElement(definitionList);
    }
    jj_consume_token(RIGHT_PAREN);
        {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public TableElementList tableElement(TableElementList definitionList) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      definitionList = columnDefinition(definitionList);
      break;
    case PRIMARY_KEY:
    case FOREIGN_KEY:
      definitionList = tableConstraintDefinition(definitionList);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public TableElementList columnDefinition(TableElementList definitionList) throws ParseException {
  String colName;
  String type;
  Token notNull = null;
  ColumnDef newDef;
    colName = columnName();
    type = dataType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT_NULL:
      notNull = jj_consume_token(NOT_NULL);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
        newDef = new ColumnDef(colName, type, (notNull==null));
    definitionList.addColumnDef(newDef);
        {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public TableElementList tableConstraintDefinition(TableElementList definitionList) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY_KEY:
      definitionList = primaryKeyConstraint(definitionList);
      break;
    case FOREIGN_KEY:
      definitionList = referentialConstraint(definitionList);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public TableElementList primaryKeyConstraint(TableElementList definitionList) throws ParseException {
  ArrayList<String> columnList;
  TableConstraintDef newDef;
    jj_consume_token(PRIMARY_KEY);
    columnList = columnNameList();
        newDef = new TableConstraintDef("PK", columnList);
        definitionList.addTableConstraintDef(newDef);
        {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public TableElementList referentialConstraint(TableElementList definitionList) throws ParseException {
  ArrayList<String> columnList, refColumnList;
  String refTableName;
  TableConstraintDef newDef;
    jj_consume_token(FOREIGN_KEY);
    columnList = columnNameList();
    jj_consume_token(REFERENCES);
    refTableName = tableName();
    refColumnList = columnNameList();
        newDef = new TableConstraintDef("FK", columnList, refTableName, refColumnList);
        definitionList.addTableConstraintDef(newDef);
        {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> columnNameList() throws ParseException {
  ArrayList<String> result = new ArrayList<String>();
  String temp;
    jj_consume_token(LEFT_PAREN);
    temp = columnName();
        result.add(temp);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      temp = columnName();
      result.add(temp);
    }
    jj_consume_token(RIGHT_PAREN);
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public String dataType() throws ParseException {
  String result;
  Token type = null;
  Token charType = null,lp = null,rp = null,value = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      type = jj_consume_token(INT);
      break;
    case CHAR:
      charType = jj_consume_token(CHAR);
      lp = jj_consume_token(LEFT_PAREN);
      value = jj_consume_token(INT_VALUE);
      rp = jj_consume_token(RIGHT_PAREN);
      break;
    case DATE:
      type = jj_consume_token(DATE);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (type == null)
    {
      if(Integer.parseInt(value.image) < 1)
        result = "errorType";
      else
            result = charType.image+lp.image+value.image+rp.image;
        }
        else result = type.image;
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public String tableName() throws ParseException {
  Token result;
    result = jj_consume_token(LEGAL_IDENTIFIER);
        {if (true) return result.image;} // PRJ2 #8 : technique that return string

    throw new Error("Missing return statement in function");
  }

  static final public String columnName() throws ParseException {
  Token result;
    result = jj_consume_token(LEGAL_IDENTIFIER);
        {if (true) return result.image;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_3R_16() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) jj_scanpos = xsp;
    if (jj_3R_16()) return true;
    return false;
  }

  static private boolean jj_3R_10() {
    if (jj_3R_11()) return true;
    if (jj_3R_12()) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  static private boolean jj_3R_13() {
    if (jj_3R_15()) return true;
    return false;
  }

  static private boolean jj_3R_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) return true;
    }
    return false;
  }

  static private boolean jj_3R_12() {
    if (jj_scan_token(COMPARISON_SIGNS)) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3R_9() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_3R_19() {
    if (jj_scan_token(DATE_VALUE)) return true;
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3R_18() {
    if (jj_scan_token(CHAR_STRING)) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_10()) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3R_17() {
    if (jj_scan_token(INT_VALUE)) return true;
    return false;
  }

  static private boolean jj_3R_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_17()) {
    jj_scanpos = xsp;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) return true;
    }
    }
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public SimpleDBMSParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[27];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x1700220,0x1700200,0x1700200,0x10000000,0x0,0x0,0x1000,0x0,0x2000000,0x4000000,0x10000000,0x0,0x4000000,0x20000000,0x40000000,0x800,0x0,0x0,0x0,0x0,0x3000,0x0,0x60000,0x2000,0x60000,0x0,0x1c0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x9,0x9,0x9,0x0,0x20,0x80,0x180200,0x80,0x1000,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x181220,0x1000,0x181200,0x180200,0x0,0x80,0x1000,0x0,0x0,0x80,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[4];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SimpleDBMSParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleDBMSParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SimpleDBMSParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SimpleDBMSParser(SimpleDBMSParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SimpleDBMSParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[55];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 27; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 55; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
