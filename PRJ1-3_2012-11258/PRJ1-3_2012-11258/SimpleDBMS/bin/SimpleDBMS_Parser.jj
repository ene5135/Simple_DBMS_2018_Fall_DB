options
{
  static = true;
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;
  IGNORE_CASE = true; //#1 for global case insensitivity, but this makes case insensitivity of identifier too 
}

////////// main parser class ////////////

PARSER_BEGIN(SimpleDBMSParser)

// import

import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;
import com.sleepycat.je.LockMode;
import com.sleepycat.bind.serial.SerialBinding;
import com.sleepycat.bind.serial.StoredClassCatalog;
import com.sleepycat.bind.EntryBinding;
import com.sleepycat.je.OperationStatus;

import java.io.File;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collections;


/* PRJ2 #7 : My table, attr structure */
  class Table implements Serializable
  {
	String tableName;
	ArrayList<Attribute> attributes;
	ArrayList<String> referencedBy; // name of table that reference this table.
	ArrayList<ForeignKey> FKs;
	ArrayList<String> PK;
	ArrayList<ArrayList<String>> records;

	Table()
	{
	  tableName = null;
	  attributes = new ArrayList<Attribute>();
	  referencedBy = new ArrayList<String>();
	  FKs = new ArrayList<ForeignKey>();
	  PK = new ArrayList<String>();
	  records = new ArrayList<ArrayList<String>>();
	}

    void makeReferencingRecordsNull(ArrayList<String> targetRecord)
    {
	  for(String refTableName : referencedBy)
	  { 
	    DatabaseEntry theKey = null;
	    try {
	    	theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
	    } catch (UnsupportedEncodingException e) {
	    	e.printStackTrace();
	    }
        DatabaseEntry theData = new DatabaseEntry();
        if(!SimpleDBMSParser.getTableFromDB(theKey, theData)) // not found
        {
          //this can not be reached
			System.out.println("can not reach here : checkNonNullableReferencing");
        }
        else // found
        {
   	      Table refTable = (Table) SimpleDBMSParser.entryBinding.entryToObject(theData);
   	      ForeignKey refTableFK = refTable.getFKByRefTableName(tableName);
   	      ArrayList<String> referencingAttrs = refTableFK.getAttrs();
   	      ArrayList<String> referencedAttrs = refTableFK.getRefedAttrs();
   	      Boolean thereAreNonNullAttr = false;
   	      ArrayList<ArrayList<String>> refTableRecords = refTable.getRecords();
   	      
   	      for(String cursor : referencingAttrs)
   	      {
			if(!refTable.getAttributeByName(cursor).getNullable())
			{
			  thereAreNonNullAttr = true;
			  break;
			}
   	      }
		  if(!thereAreNonNullAttr)// non-null col이 하나도 없어야 null로 만들 수 있음
		  {
			
			  ArrayList<Integer> referencingAttrsIndex = new ArrayList<Integer>();
			  for(String cursor : referencingAttrs)
			  {
				referencingAttrsIndex.add(refTable.getIndexByAttrName(cursor));
			  }
			  
			  ArrayList<Integer> referencedAttrsIndex = new ArrayList<Integer>();
			  for(String cursor : referencedAttrs)
			  {
				referencedAttrsIndex.add(getIndexByAttrName(cursor));
			  }

			  int j=0;
			  for(ArrayList<String> recCursor : refTableRecords) // 쪼는 테이블 레코드들 보면서 지우려는 레코드랑 같은 레코드 존재하는지 확인
			  // 위에서 nonNullattr가 있단걸 확인했으므로 겹치면 못지움
			  {
			    Boolean temp = true;
				for(int i=0;i<referencedAttrsIndex.size();i++)
				{
				  if(!targetRecord.get(referencedAttrsIndex.get(i)).equals(recCursor.get(referencingAttrsIndex.get(i))))
				  {
					temp = false;
				  }
				}
				if(temp)// 모든 attr가 같으면
				{
				  for(int i=0;i<referencingAttrsIndex.size();i++) // null로 바꾸고
				  {
					recCursor.set(referencingAttrsIndex.get(i),"null");
				  }
				  refTableRecords.set(j,recCursor); // 바꿔끼우고
				  refTable.setRecord(refTableRecords);

					//db에 저장
				  SimpleDBMSParser.entryBinding.objectToEntry(refTable,theData); 
				  SimpleDBMSParser.myDatabase.put(null, theKey, theData); // overwrite updated record
				  SimpleDBMSParser.myDatabase.sync();
				}
				j++; 
			  }

		  }     
   	    }
   	  }
    }

	Boolean canBeDeleted(ArrayList<String> targetRecord)
	{
	  for(String refTableName : referencedBy)
	  { 
	    DatabaseEntry theKey = null;
	    try {
	    	theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
	    } catch (UnsupportedEncodingException e) {
	    	e.printStackTrace();
	    }
        DatabaseEntry theData = new DatabaseEntry();
        if(!SimpleDBMSParser.getTableFromDB(theKey, theData)) // not found
        {
          //this can not be reached
			System.out.println("can not reach here : checkNonNullableReferencing");
        }
        else // found
        {
   	      Table refTable = (Table) SimpleDBMSParser.entryBinding.entryToObject(theData);
   	      ForeignKey refTableFK = refTable.getFKByRefTableName(tableName);
   	      ArrayList<String> referencingAttrs = refTableFK.getAttrs();
   	      ArrayList<String> referencedAttrs = refTableFK.getRefedAttrs();
   	      Boolean thereAreNonNullAttr = false;
   	      ArrayList<ArrayList<String>> refTableRecords = refTable.getRecords();
   	      
   	      for(String cursor : referencingAttrs)
   	      {
			if(!refTable.getAttributeByName(cursor).getNullable())
			{
			  thereAreNonNullAttr = true;
			  break;
			}
   	      }
		  if(!thereAreNonNullAttr)// non-null col이 하나도 없으면 걍 가능, 다음 쪼는 테이블로 넘어감
		    continue;

		  ArrayList<Integer> referencingAttrsIndex = new ArrayList<Integer>();
		  for(String cursor : referencingAttrs)
		  {
			referencingAttrsIndex.add(refTable.getIndexByAttrName(cursor));
		  }
		  
		  ArrayList<Integer> referencedAttrsIndex = new ArrayList<Integer>();
		  for(String cursor : referencedAttrs)
		  {
			referencedAttrsIndex.add(getIndexByAttrName(cursor));
		  }
		  
		  for(ArrayList<String> recCursor : refTableRecords) // 쪼는 테이블 레코드들 보면서 지우려는 레코드랑 같은 레코드 존재하는지 확인
		  // 위에서 nonNullattr가 있단걸 확인했으므로 겹치면 못지움
		  {
		    Boolean temp = true;
			for(int i=0;i<referencedAttrsIndex.size();i++)
			{
			  if(!targetRecord.get(referencedAttrsIndex.get(i)).equals(recCursor.get(referencingAttrsIndex.get(i))))
			  {
				temp = false;
			  }
			}
			if(temp)// 모든 attr가 같으면
			  return false; 
		  }
		     	      
   	    }
   	  }
   	  return true;
	}

	Integer getIndexByAttrName(String attrName)
	{
	  Integer i = 0;
	  for(Attribute cursor : attributes)
	  {
		if(cursor.getAttrName().equalsIgnoreCase(attrName))
		{
		  return i;
		}
		i++;
	  }
	  return -1;// can not be reached
	}

	ForeignKey getFKByRefTableName(String refTableName)
	{
	  for(ForeignKey cursor : FKs)
	  {
		if(cursor.getRefTableName().equalsIgnoreCase(refTableName))
		  return cursor;
	  }
	  return null;
	}

//foreign key 하나씩 돌면서 foreign key attr 인덱스 표시하고 해당 테이블의 레코드 가져와서
// 그 테이블의 foreign key attr 표시해서 쭉 비교

	void setRecord(ArrayList<ArrayList<String>> newRecords)
	{
	  records = newRecords;
	}

	Boolean checkForeignConstraint(ArrayList<String> newRecord)
	{
	  for(ForeignKey foreignKeyCursor : FKs)
	  {
	   
	    String refTableName = foreignKeyCursor.getRefTableName();
	    
	    DatabaseEntry theKey = null;
	    try {
	    	theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
	    } catch (UnsupportedEncodingException e) {
	    	e.printStackTrace();
	    }
        DatabaseEntry theData = new DatabaseEntry();
        if(!SimpleDBMSParser.getTableFromDB(theKey, theData)) // not found
        {
          //this can not be reached
			System.out.println("Create table has failed: foreign key references non existing table");
			SimpleDBMSParser.ReInit(System.in);
        }
        else // found
        {
   	      Table refTable = (Table) SimpleDBMSParser.entryBinding.entryToObject(theData);
		  ArrayList<String> referencingAttrs = foreignKeyCursor.getAttrs();
		  ArrayList<String> referencedAttrs = foreignKeyCursor.getRefedAttrs();
   	      
		  ArrayList<String> sortedNewRecord = new ArrayList<String>(Collections.nCopies(referencingAttrs.size(),""));
		  ArrayList<String> foreignKeyIndexForNewRecord = new ArrayList<String>(Collections.nCopies(attributes.size(),""));
// referencing attr 순서에 맞는 인덱스 얻기
		  int i = 0;
		  for(Attribute cursor : attributes)
		  {
		    int j = 0;
			for(String temp : referencingAttrs)
		    {
			  if(temp.equalsIgnoreCase(cursor.getAttrName()))
			  {
			    foreignKeyIndexForNewRecord.set(i,Integer.toString(j));
			  	break;
			  }
			  j++;
		    }	
			if(j==referencingAttrs.size())
			  foreignKeyIndexForNewRecord.set(i,"null");
			i++;
		  }
// 그 인덱스에 맞게 소팅
		  i = 0;
		  for(String cursor : newRecord)
		  {
		    if(!foreignKeyIndexForNewRecord.get(i).equals("null"))
		    {   
			  sortedNewRecord.set(Integer.parseInt(foreignKeyIndexForNewRecord.get(i)),cursor);
			}
			i++;
		  }

		  Boolean tempBool = false;
		  ArrayList<ArrayList<String>> refedRecords = refTable.getRecords();
	      for(ArrayList<String> recCursor : refedRecords)
	      {
	       
	        ArrayList<String> sortedRefedRecord = new ArrayList<String>(Collections.nCopies(referencedAttrs.size(),""));
		    ArrayList<String> foreignKeyIndexForRefedRecord = new ArrayList<String>(Collections.nCopies(refTable.getAttrs().size(),""));
			// referenced attr 순서에 맞는 인덱스 얻기
			  i = 0;
			  for(Attribute cursor : refTable.getAttrs())
			  {
			    int j = 0;
				for(String temp : referencedAttrs)
			    {
				  if(temp.equalsIgnoreCase(cursor.getAttrName()))
				  {
			  	 	foreignKeyIndexForRefedRecord.set(i,Integer.toString(j));
			  		break;
			 	  }
			  	  j++;
			    }	
				if(j==referencedAttrs.size())
				  foreignKeyIndexForRefedRecord.set(i,"null");
				i++;
			  }
	// 그 인덱스에 맞게 소팅
			  i = 0;
			  for(String cursor : recCursor)
			  {
				if(!foreignKeyIndexForRefedRecord.get(i).equals("null"))
		    	{   
			  	  sortedRefedRecord.set(Integer.parseInt(foreignKeyIndexForRefedRecord.get(i)),cursor);
				}
				i++;
			  }

			  // 이제 sortedRefedRecord랑  sortedNewRecord 비교해서 bool 값 조지면 됨			  
			  if(equalsStringList(sortedNewRecord, sortedRefedRecord))
			    tempBool = true;
	      }
	      if(!tempBool)
	      	return false;
        }
	  }

	  return true;	   
	}

	Boolean equalsStringList(ArrayList<String> l, ArrayList<String> r)
	{
	  Boolean temp = true;
	  for(int i = 0; i<l.size();i++)
	  {
	    if(!l.get(i).equals(r.get(i)))
		  temp = false;
	  }
	  return temp;
	}

	// primary key인 value가 겹치는게 있는지, true : good, false : bad
 	Boolean checkPrimaryConstraint(ArrayList<String> newRecord)
 	{
 	  int i=0;
 	  ArrayList<ArrayList<String>> temp = new ArrayList<ArrayList<String>>(records);
	  for(Attribute cursor : attributes)
	  {
	    if(isPK(cursor.getAttrName())||PK.isEmpty()) // pk가 없으면 전체 다 봄.
	    {
	      for(int j=0;j<temp.size();j++)
	      {
	        if(!temp.get(j).get(i).equals(newRecord.get(i)))
	        {
	          temp.remove(j);
	          j--;
	        }
	      }
	    }
	    i++;
	  }

	  if(temp.isEmpty())
	  {
		return true;
	  }
	  else
	  {
	    return false;
	  }
 	}

 	ArrayList<ArrayList<String>> getRecords()
 	{
	  return records;
 	}

	void markPKsNotNull()
	{
	  for(String PKCursor : PK)
	  {
		for(Attribute attrCursor : attributes)
		{
		  if(PKCursor.equalsIgnoreCase(attrCursor.getAttrName()))
		  	attrCursor.setNullable(false);
		}
	  }
	}
	static Boolean containsCaseInsen(ArrayList<String> arrayList, String target)
    {
	  Boolean result = false;
	  for(String cursor : arrayList)
	  {
	    result = result || cursor.equalsIgnoreCase(target);
	  }
	  return result;
    }
	Boolean containsAttr(String attrName)
	{
	  Boolean result = false;
	  for(Attribute cursor : attributes)
	  {
		if(cursor.getAttrName().equalsIgnoreCase(attrName))
		  result = true;
	  }
	  return result;
	}
	Attribute getAttributeByName(String attrName)
	{
	  Attribute result = null;
	  for(Attribute cursor : attributes)
	  {
		if(cursor.getAttrName().equalsIgnoreCase(attrName))
		  return cursor;
	  }
	  return result;
	}
	ArrayList<String> getPK()
	{
	  return PK;
	}
	void addToRefBy(String referencingTableName)
	{
	  referencedBy.add(referencingTableName);
	}
	ArrayList<ForeignKey> getFKs()
	{
	  return FKs;
	}
	void deleteFromRefBy(String target)
	{
	  referencedBy.remove(target);
	}
	Boolean isFK(String attrName)
	{
	  Boolean result = false;
	  for(ForeignKey cursor : FKs)
	  {
	    result = result || containsCaseInsen(cursor.getAttrs(), attrName);
	  }
	  return result;
	}
	Boolean isPK(String attrName)
	{
	  return containsCaseInsen(PK, attrName);
	}
	ArrayList<Attribute> getAttrs()
	{
	  return attributes;
	}
	void addFK(ForeignKey newFK)
	{
	  FKs.add(newFK);
	}
	void addPKs(ArrayList<String> newPKs)
	{
	  PK.addAll(newPKs);
	}
	String getTableName()
	{
	  return tableName;
	}
	Boolean isReferenced()
	{
	  return (!referencedBy.isEmpty());
	}
	void setTableName(String argTableName)
	{
	  tableName = argTableName;
	}
	void addAttr(Attribute attr)
	{
	  attributes.add(attr);
	}
  }

  class Pair<E,F> implements Serializable
  {
	E left;
	F right;
	Pair(E l, F r)
	{
	  left = l;
	  right = r;
	}

	E getLeft()
	{
	  return left;
	}
	F getRight()
	{
	  return right;
	}
  }

  class Attribute implements Serializable
  {
	String tableName;
	String attrName;
	String type;
	Boolean nullable;

	Attribute()
	{
	  tableName = null;
	  attrName = null;
	  type = null;
	  nullable = true;
	}
	Attribute(String argTN, String argAN, String argType, Boolean argNullable)
	{
	  tableName = argTN;
	  attrName = argAN;
	  type = argType;
	  nullable = argNullable;
	}

	String getAttrName()
	{
	  return attrName;
	}
	String getType()
	{
	  return type;
	}
	Boolean getNullable()
	{
	  return nullable;
	}
	void setTableName(String argTN)
	{
	  tableName = argTN;
	}
	void setAttrName(String argAN)
	{
	  attrName = argAN;
	}
	void setType(String argType)
	{
	  type = argType;
	}
	void setNullable(Boolean argNullable)
	{
	  nullable = argNullable;
	}
  }

  class ForeignKey implements Serializable // Foreign key : list to list referencing
  {
	ArrayList<String> referencingAttrs;
	String referencedTable;
	ArrayList<String> referencedAttrs;

	ForeignKey(ArrayList<String> argReferencing, String argReferencedTable, ArrayList<String> argReferenced)
	{
	  referencingAttrs = argReferencing;
	  referencedTable = argReferencedTable; 
	  referencedAttrs = argReferenced; 
	}

	String getRefTableName()
	{
	  return referencedTable;
	}
	ArrayList<String> getAttrs()
	{
	  return referencingAttrs;
	}
	ArrayList<String> getRefedAttrs()
	{
	  return referencedAttrs;
	}
  }


////////////// PRJ2 #9 : need these classes to execute column definition before table constraint definition for any order of input statement
  class TableElementList implements Serializable
  {
	ArrayList<ColumnDef> columnDefList;
	ArrayList<TableConstraintDef> tableConstraintDefList;

	TableElementList()
	{
	  columnDefList = new ArrayList<ColumnDef>();
	  tableConstraintDefList = new ArrayList<TableConstraintDef>();
	}

	ArrayList<TableConstraintDef> getConstDefList()
	{
	  return tableConstraintDefList;
	}
	ArrayList<ColumnDef> getColumnDefList()
	{
	  return columnDefList;
	}
	void addColumnDef(ColumnDef newDef)
	{
	  columnDefList.add(newDef);
	}
	void addTableConstraintDef(TableConstraintDef newDef)
	{
	  tableConstraintDefList.add(newDef);
	}
  }

  class ColumnDef implements Serializable
  {
	String columnName;
	String dataType;
	Boolean nullable;

	ColumnDef(String argColName, String argType, Boolean argNullable)
	{
	  columnName = argColName;
	  dataType = argType;
	  nullable = argNullable;
	}

	String getColumnName()
	{
	  return columnName;
	}
	String getDataType()
	{
	  return dataType;
	}
	Boolean getNullable()
	{
	  return nullable;
	}
  }

  class TableConstraintDef implements Serializable
  {
	String type; // "FK" or "PK"
	ArrayList<String> attrs;
	String referencedTable; // for only FK
	ArrayList<String> referencedAttrs; // for only FK

	TableConstraintDef(String argType, ArrayList<String> argAttrs)
	{
	  type = argType;
	  attrs = argAttrs;
	  referencedTable = null;
	  referencedAttrs = null;
	}
	TableConstraintDef(String argType, ArrayList<String> argAttrs, String argReferencedTable, ArrayList<String> argReferencedAttrs)
	{
	  type = argType;
	  attrs = argAttrs;
	  referencedTable = argReferencedTable;
	  referencedAttrs = argReferencedAttrs;
	}

	String getRefTableName()
	{
	  return referencedTable;
	}
	ArrayList<String> getRefAttrs()
	{
	  return referencedAttrs;
	}
	ArrayList<String> getAttrs()
	{
	  return attrs;
	}
	String getType()
	{
	  return type;
	}
  }

public class SimpleDBMSParser
{
  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE = 2;
  public static final int PRINT_DESC = 3;
  public static final int PRINT_SELECT = 4;
  public static final int PRINT_INSERT = 5;
  public static final int PRINT_DELETE = 6;
  public static final int PRINT_SHOW_TABLES = 7;

  // Environment & Database declarations
  public static Environment myDbEnvironment = null;
  public static Database myDatabase = null;
  public static Database myClassDb = null;
  public static Cursor cursor = null;
  public static StoredClassCatalog scc = null;
  public static EntryBinding entryBinding = null;
  public static DatabaseEntry foundKey = null;
  public static DatabaseEntry foundData = null;
  public static ArrayList<String> currFromTables = null;
  public static ArrayList<String> currOriginalNames = null;
  
  public static void main(String args[]) throws ParseException
  {
	/* OPENING DB */

	// Open Database Environment or if not, create one.
	EnvironmentConfig envConfig = new EnvironmentConfig();
	envConfig.setAllowCreate(true);
	myDbEnvironment = new Environment(new File("db/"), envConfig);

	// Open Database or if not, create one.
	// Initializations
	DatabaseConfig dbConfig = new DatabaseConfig();
	dbConfig.setAllowCreate(true);
	dbConfig.setSortedDuplicates(false);
	dbConfig.setDeferredWrite(true); // PRJ2 #1 : set this option to use sync() function.
	myDatabase = myDbEnvironment.openDatabase(null, "sampleDatabase", dbConfig);
	dbConfig.setSortedDuplicates(false);
    myClassDb = myDbEnvironment.openDatabase(null, "classDb", dbConfig);
    scc = new StoredClassCatalog(myClassDb);
	entryBinding = new SerialBinding(scc,Table.class); // PRJ2 #0 : My DB stores <String(=key), Object(=value)>. Techniques to store object in value. using binding
	cursor = myDatabase.openCursor(null, null);
	foundKey = new DatabaseEntry();
	foundData = new DatabaseEntry();

	
    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
    System.out.print("DB_2012-11258> ");

    while (true)
    {
      try
      {
        parser.command();
      }
      catch (ParseException e)
      {
       // e.printStackTrace();
        printMessage(PRINT_SYNTAX_ERROR);
        SimpleDBMSParser.ReInit(System.in);
      }
      catch (Exception e)
      {
        System.out.println(e.getMessage());
        //e.printStackTrace();
        System.out.print("DB_2012-11258> ");    
		SimpleDBMSParser.ReInit(System.in);
      }
    }
  }

  
/* PRJ2 #2 : this function put <Key(=String), Object > into DB. */
  public static void putObjectEntry(String keyString, Object obj) throws Exception
  {
	try {
	  DatabaseEntry key;
	  DatabaseEntry data;

	  key = new DatabaseEntry(keyString.getBytes("UTF-8"));
	  data = new DatabaseEntry();

	  entryBinding.objectToEntry(obj,data); // PRJ2 #0 : My DB stores <String(=key), Object(=value)>. Techniques to store object in value.

	  if(tableExist(keyString))
		// this exception must not be executed
	  	throw new Exception("Create table has failed: table with the same name already exists"); 
	  myDatabase.putNoOverwrite(null, key, data);
	  myDatabase.sync(); // PRJ2 #1 : To save db file immediately.
	} catch (DatabaseException de) {
	  de.printStackTrace();
	} catch (UnsupportedEncodingException e) {
	  e.printStackTrace();
	}
  }

//PRJ2 #6 : requested message should be removed
  public static void printMessage(int q)
  {
    //System.out.print("DB_2012-11258> ");
    switch(q)
    {
      case PRINT_SYNTAX_ERROR:
      	System.out.println("Syntax error");
      	break;
      	/*
      case PRINT_CREATE_TABLE:
      	System.out.println("\'CREATE TABLE\' requested");
      	break;
      case PRINT_DROP_TABLE:
      	System.out.println("\'DROP TABLE\' requested");
      	break;
      case PRINT_DESC:
      	System.out.println("\'DESC\' requested");
      	break;
      case PRINT_SHOW_TABLES:
	    System.out.println("\'SHOW TABLES\' requested");
      	break;
      	*/
     /* case PRINT_SELECT:
      	System.out.println("\'SELECT\' requested");
      	break;*/
      /*case PRINT_INSERT:
      	System.out.println("\'INSERT\' requested");
      	break;*/
    /*  case PRINT_DELETE:
      	System.out.println("\'DELETE\' requested");
      	break;*/
    }
    System.out.print("DB_2012-11258> ");
  }

  static Boolean containsCaseInsen(ArrayList<String> arrayList, String target)
  {
	Boolean result = false;
	for(String cursor : arrayList)
	{
	  result = result || cursor.equalsIgnoreCase(target);
	}
	return result;
  }

  static Boolean getTableFromDB(DatabaseEntry theKey, DatabaseEntry theData) // case insensitive get. not found = null
  {
    Boolean result = false;
	if (cursor.getFirst(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.NOTFOUND)
	{ // empty db case
	  return result;
	}
	else
	{
	  do // traverse entire db
	  {     
	    String res_key = null;
	    String target = null;
	    try {
	      		target = new String(theKey.getData(), "UTF-8");
	   			res_key = new String(foundKey.getData(), "UTF-8");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
	    if(res_key.equalsIgnoreCase(target))
	    { 
	      entryBinding.objectToEntry((Table) entryBinding.entryToObject(foundData),theData);
	      try { theKey.setData(res_key.getBytes("UTF-8")); }
	      catch (UnsupportedEncodingException e) {	e.printStackTrace(); }
	      result = true;
	      return result;
	    }  
	  } while (cursor.getNext(foundKey, foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);
	}
	return result;
  }

  static void addAllReferencedBy(String tableName, TableElementList definitionList) throws Exception
  {
    ArrayList<TableConstraintDef> tableConstraintDefList = definitionList.getConstDefList();
	String refTableName;
	ArrayList<String> keyAttrs, refAttrs;

	for (TableConstraintDef cursor : tableConstraintDefList)
	{
	  if(cursor.getType().equals("FK"))
	  {
		keyAttrs = cursor.getAttrs();
	    refTableName = cursor.getRefTableName();
	    refAttrs = cursor.getRefAttrs();
	    
	    DatabaseEntry theKey = null;
	    try {
	    	theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
	    } catch (UnsupportedEncodingException e) {
	    	e.printStackTrace();
	    }
        DatabaseEntry theData = new DatabaseEntry();
        if(!getTableFromDB(theKey, theData)) // not found
        {
          //this can not be reached
          throw new Exception("Create table has failed: foreign key references non existing table");
        }
        else // found
        {
   	      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
		  
	      retrievedTable.addToRefBy(tableName);
		  entryBinding.objectToEntry(retrievedTable,theData); 
	 	  myDatabase.put(null, theKey, theData); // overwrite updated record
	 	  myDatabase.sync();
        }
	  }
	}
  }

  static Boolean tableExist(String tableName)
  {
	DatabaseEntry theKey = null;
	try {
		theKey = new DatabaseEntry(tableName.getBytes("UTF-8"));
	} catch (UnsupportedEncodingException e) {
		e.printStackTrace();
	}
    DatabaseEntry theData = new DatabaseEntry();
    return getTableFromDB(theKey, theData);
  }

  static void deleteReference(Table table)
  {
    String referencedTableName;
    for(ForeignKey cursor : table.getFKs())
    {
      referencedTableName = cursor.getRefTableName();
      DatabaseEntry theKey = null;
	  try {
	  	theKey = new DatabaseEntry(referencedTableName.getBytes("UTF-8"));
	  } catch (UnsupportedEncodingException e) {
	  	e.printStackTrace();
	  }
      DatabaseEntry theData = new DatabaseEntry();
      if(!getTableFromDB(theKey, theData)) // not found
      {
        System.out.println("Fatal error : code cannot reach here(deleteReference())");
      }
      else // found
      {
   	    Table retrievedTable = (Table) entryBinding.entryToObject(theData);
	    retrievedTable.deleteFromRefBy(table.getTableName());
	    entryBinding.objectToEntry(retrievedTable,theData); 
	 	myDatabase.put(null, theKey, theData); // overwrite updated record
	 	myDatabase.sync();
      }
    }
  }

/* PRJ2 #12 : this function check whether the attr is key or not and return the string like PRI, FOR, PRI/FOR
*/
  static String whatKey(Table table, String attrName)
  {
	String result = new String("");
	String slash = new String("");
	if(table.isPK(attrName))
	{
	  result = result + "PRI";
	  slash = "/";
	}
	if(table.isFK(attrName))
	  result = result + slash + "FOR";

	return result;
  }

/* PRJ2 #10 : this function add new columns to table, traversing column definition list */
  static Table makeColumns(Table newTable, TableElementList definitionList) throws Exception
  {
	ArrayList<ColumnDef> columnDefList = definitionList.getColumnDefList();
	Attribute newAttr;
	String tableName = newTable.getTableName();
	String newColumnName, newColumnType;
	Boolean newColumnNullable;
	
	for (ColumnDef cursor : columnDefList)
	{
	  newColumnName = cursor.getColumnName();
	  newColumnType = cursor.getDataType();
	  newColumnNullable = cursor.getNullable();

	  for(Attribute attrCursor : newTable.getAttrs()) // check dup col
	  {
	    if(attrCursor.getAttrName().equalsIgnoreCase(newColumnName))
	      throw new Exception("Create table has failed: column definition is duplicated");
	  }
	  if(newColumnType.equals("errorType"))
	    throw new Exception("Char length should be over 0");
	  
	  newAttr = new Attribute(tableName, newColumnName, newColumnType, newColumnNullable);
	  newTable.addAttr(newAttr);
	}

	return newTable;
  }

/* PRJ2 #11 : this function apply new constraints to table, traversing column definition list */
  static Table applyConstraints(Table newTable, TableElementList definitionList) throws Exception
  {
	ArrayList<TableConstraintDef> tableConstraintDefList = definitionList.getConstDefList();
	ForeignKey newForeignKey;
	String refTableName;
	ArrayList<String> keyAttrs, refAttrs;

	for (TableConstraintDef cursor : tableConstraintDefList)
	{
	  if(cursor.getType().equals("PK"))
	  {
	    keyAttrs = cursor.getAttrs();
	    if(!newTable.getPK().isEmpty()) // already exist pk
	      throw new Exception("Create table has failed: primary key definition is duplicated");

	    for(String strCursor : keyAttrs) // 존재하지 않는 컬럼을 primary key로 정의한 경우
		{
		  if(!newTable.containsAttr(strCursor))
		  	throw new Exception("Create table has failed: '"+ strCursor +"' does not exists in column definition");
		}
		
	    newTable.addPKs(keyAttrs);
	    newTable.markPKsNotNull();
	  }
	  else // "FK" case
	  {
	    keyAttrs = cursor.getAttrs();
	    refTableName = cursor.getRefTableName();
	    refAttrs = cursor.getRefAttrs();

		DatabaseEntry theKey = null;
	    try {
	    	theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
	    } catch (UnsupportedEncodingException e) {
	    	e.printStackTrace();
	    }
        DatabaseEntry theData = new DatabaseEntry();
        if(!getTableFromDB(theKey, theData)) // not found
        {
          throw new Exception("Create table has failed: foreign key references non existing table");
        }
        
   	    Table retrievedTable = (Table) entryBinding.entryToObject(theData);
   	    
		ArrayList<Attribute> newTableAttrs = newTable.getAttrs();
		ArrayList<Attribute> refTableAttrs = retrievedTable.getAttrs();
		ArrayList<Attribute> newTableFKAttrs = new ArrayList<Attribute>();
		ArrayList<Attribute> refTableFKAttrs = new ArrayList<Attribute>();
		ArrayList<String> typeList = new ArrayList<String>();

		for(String strCursor : keyAttrs) // 존재하지 않는 컬럼을 foreign key로 정의한 경우
		{
		  if(!newTable.containsAttr(strCursor))
		  	throw new Exception("Create table has failed: '"+ strCursor +"' does not exists in column definition");
		}
		for(String strCursor : refAttrs) 
		{
		  if(!retrievedTable.containsAttr(strCursor)) // Foreign key가 존재하지 않는 컬럼을 참조한다면, ReferenceColumnExistenceError에 해당하는 메시지 출력
		  	throw new Exception("Create table has failed: foreign key references non existing column");
		  if((!containsCaseInsen(retrievedTable.getPK(), strCursor)) || (retrievedTable.getPK().size() != refAttrs.size())) // Foreign key가 primary key가 아닌 컬럼을 참조한다면, 
			throw new Exception("Create table has failed: foreign key references non primary key column");
		}

		// Foreign key의 타입과 foreign key가 참조하는 컬럼의 개수나 타입이 서로 다른 경우,
		// ReferenceTypeError에 해당하는 메시지 출력
		for(Attribute attrCursor : newTableAttrs)
		{
		  if(containsCaseInsen(keyAttrs, attrCursor.getAttrName()))
		    newTableFKAttrs.add(attrCursor);
		}
		for(Attribute attrCursor : refTableAttrs)
		{
		  if(containsCaseInsen(refAttrs, attrCursor.getAttrName()))
		    refTableFKAttrs.add(attrCursor);
		}
	
		for(Attribute attrCursor : newTableFKAttrs)
		{
		  typeList.add(attrCursor.getType());
		}
		for(Attribute attrCursor : refTableFKAttrs)
		{
		  typeList.remove(attrCursor.getType());
		}
	
		if((keyAttrs.size() != refAttrs.size())||(!typeList.isEmpty())) // number of foreign key col and refed col are different 
		  throw new Exception("Create table has failed: foreign key references wrong type");	

		for(ForeignKey FKCursor : newTable.getFKs()) // PRJ2 #13 : additional error case. the column references multiple tables
		{
		  for(String newAttr : keyAttrs)
		  {
			if(containsCaseInsen(FKCursor.getAttrs(), newAttr))
			  throw new Exception("Create table has failed: the column references multiple tables");
		  }
		}
		
	    newForeignKey = new ForeignKey(keyAttrs, refTableName, refAttrs);
	    newTable.addFK(newForeignKey);
	  }
	}
	addAllReferencedBy(newTable.getTableName(), definitionList);
		
	return newTable;
  }


  // 리스트 내에 같은 스트링이 존재하는지 검사
  static Boolean checkDup(ArrayList<String> input)
  {
	for(String cursor : input)
	{
	  ArrayList<String> temp = new ArrayList<String>(input);
	  temp.remove(cursor);
	  if(Table.containsCaseInsen(temp, cursor))
	  	return true;
	}
	return false;
  }

  static Boolean isType(String input)
  {
	if(input.equals("int") || input.equals("date") || input.equals("char"))
	  return true;
	else
	  return false;  
  }

  // charString 의 양끝 ' 없에기
  static String removeQuote(String input)
  {
	return input.substring(1,input.length()-1);
  }

  //op : "<" | ">" | "=" | "<=" | ">=" | "!="
  static String compareTwoValues(String l, String op, String r, Boolean isInt)
  {
	if(l.equals("null") || r.equals("null"))
	  return "unknown";
	
	if(op.equals("<"))
	{
	  if(isInt)
	    return String.valueOf(Integer.parseInt(l) < Integer.parseInt(r));
	  return String.valueOf(l.compareTo(r) < 0);
	}
	else if(op.equals(">"))
	{
	  if(isInt)
	    return String.valueOf(Integer.parseInt(l) > Integer.parseInt(r));
	  return String.valueOf(l.compareTo(r) > 0);
	}
	else if(op.equals("="))
	{
	  if(isInt)
	    return String.valueOf(Integer.parseInt(l) == Integer.parseInt(r));
	  return String.valueOf(l.equals(r));
	}
	else if(op.equals("<="))
	{
	  if(isInt)
	    return String.valueOf(Integer.parseInt(l) <= Integer.parseInt(r));
	  return String.valueOf(l.compareTo(r) <= 0);
	}
	else if(op.equals(">="))
	{
	  if(isInt)
	    return String.valueOf(Integer.parseInt(l) >= Integer.parseInt(r));
	  return String.valueOf(l.compareTo(r) >= 0);
	}
	else if(op.equals("!="))
	{
	  if(isInt)
	    return String.valueOf(Integer.parseInt(l) != Integer.parseInt(r));
	  return String.valueOf(!l.equals(r));
	}

	return "false"; // can not reach here

  }

  static Pair<Integer, String> getColIndexAndType(int tableIndex, String colName)
  {
	int i = 0;
	int result = 0;

	for(String cursor : currOriginalNames)
	{
	  DatabaseEntry theKey = null;
	  try {
	  	theKey = new DatabaseEntry(cursor.getBytes("UTF-8"));
	  } catch (UnsupportedEncodingException e) {
	  	e.printStackTrace();
	  }
      DatabaseEntry theData = new DatabaseEntry();
      if(!getTableFromDB(theKey, theData)) // not found
      {
        System.out.println("Fatal error : code cannot reach here");
      }
      else // found
      {
        Table retrievedTable = (Table) entryBinding.entryToObject(theData);

        if(i == tableIndex)
        {
          int j = 0;
		  for(Attribute attrCursor : retrievedTable.getAttrs())
		  {
			if(colName.equalsIgnoreCase(attrCursor.getAttrName()))
			  return new Pair<Integer, String>(result + j, attrCursor.getType());
			j++;
		  }
        }
        else
		  result = result + retrievedTable.getAttrs().size();
      }
      i++;

	}
	return null; // can not reach here

  }
  
  static ArrayList<ArrayList<String>> carteProduct(ArrayList<ArrayList<String>> left, ArrayList<ArrayList<String>> right)
  {
	ArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();

	for(ArrayList<String> leftCursor : left)
	{
	  for(ArrayList<String> rightCursor : right)
	  {
	    ArrayList<String> temp = new ArrayList<String>(leftCursor);
	    temp.addAll(rightCursor);
		result.add(temp);
	  }
	}

	return result;	
  }

  static void printIter(String str, int count)
  {
	for(int i=0;i<count;i++)
	{
	  System.out.print(str);
	}

  }
}

PARSER_END(SimpleDBMSParser)

///////// SKIP definition /////////////

SKIP : { " " | "\r" | "\t" | "\n" } // to make spaces in a query ignored.


///////////// TOKEN definition //////////////

TOKEN : /* Keywords */ //#2 all keywords are defined first. to make keywords don't be recognized as LEGAL_IDENTIFIER
{
  < EXIT : "exit" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < CREATE : "create" > //#3 because "create", "table" can not be an identifier, keyword that consists of spaces should be defined like this. To make each word be recognized as keyword independently.
| < TABLE : "table" >
//| < CREATE_TABLE : "create table" >	
//| < CREATE_TABLE : < CREATE > < SPACE > < TABLE > > 
| < NOT : "not" >
| < NULL : "null" >
//| < NOT_NULL : < NOT > " " < NULL > >
| < NOT_NULL : "not null" >
| < PRIMARY : "primary" >
| < FOREIGN : "foreign" >
| < KEY : "key" >
//| < PRIMARY_KEY : < PRIMARY > " " < KEY > >
//| < FOREIGN_KEY : < FOREIGN > " " < KEY > >
| < PRIMARY_KEY : "primary key" >
| < FOREIGN_KEY : "foreign key" >
| < REFERENCES : "references" >
| < DROP : "drop" >
//| < DROP_TABLE : < DROP > " " < TABLE > >
//| < DROP_TABLE : "drop table" >
| < DESC : "desc" >
| < SHOW : "show" >
| < TABLES : "tables" >
//| < SHOW_TABLES : < SHOW > " " < TABLES > >
//| < SHOW_TABLES : "show tables" >
| < SELECT : "select" >
| < ASTERISK : "*" >
| < AS : "as" >
| < FROM : "from" >
| < WHERE : "where" >
| < OR : "or" >
| < AND : "and" >
| < IS : "is" >
| < INSERT : "insert" >
| < INTO : "into" >
//| < INSERT_INTO : "insert into" >
| < VALUES : "values" >
| < DELETE : "delete" >
//| < DELETE_FROM : "delete from" >

//| < #SPACE : " " >

}

TOKEN :
{
  < SEMICOLON : ";" >
| < LEFT_PAREN : "(" >
| < RIGHT_PAREN : ")" >
| < COMMA : "," >
| < UNDERSCORE : "_" >
| < INT_VALUE : (< SIGN >)? (< DIGIT >)+>
| < SIGN : "+" | "-" >
| < DIGIT : [ "0"-"9" ] >
| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >
| < ALPHABET : [ "a"-"z", "A"-"Z" ] >
| < PERIOD : "." >
| < COMPARISON_SIGNS : "<" | ">" | "=" | "<=" | ">=" | "!=" > // #5 add inequality signs and equality sign to token 
| < QUOTE : "'" >
| < NON_QUOTE_SPECIAL_CHARACTERS : "`"|"~"|"!"|"@"|"#"|"$"|"%"|"^"|"&"|"*"|"("|")"|"-"|"_"|"="|"+"|"["|"]"|"{"|"}"|"\\"|";"|":"|"<"|","|"."|">"|"/"|"?"|"|" >
| < NON_QUOTE_CHARACTERS : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | " " > 
| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTERS >)* < QUOTE > >
| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > > 
| < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >
| < NN : < DIGIT > < DIGIT > >
//| < #SPACE : " " > #6 this line cause error. duplicate with SKIP definition. so use " ", instead of < SPACE >

}

///////////////// Query rules ////////////////

/*

<COMMAND> ::= <QUERY LIST>
| exit <SEMICOLON>
<QUERY LIST> ::= (<QUERY> <SEMICOLON>)+
<QUERY> ::= <CREATE TABLE QUERY>
| <DROP TABLE QUERY>
| <DESC QUERY>
| <SELECT QUERY>
| <INSERT QUERY>
| <DELETE QUERY>
| <SHOW TABLES QUERY>
<SEMICOLON> ::= ;

*/

void command() throws Exception:
{}
{
  queryList()
| (
    < EXIT >
    < SEMICOLON >
    {      
      /* CLOSING DB */
	  if (cursor != null) cursor.close();
	  if (myDatabase != null) myDatabase.close();
	  if (myDatabase != null) myClassDb.close();
	  if (myDbEnvironment != null) myDbEnvironment.close();
	  
      System.exit(0);
    }
  ) 
}

void queryList() throws Exception:
{
  int q;
}
{
  (
    q = query()
    //< SEMICOLON >  PRJ2 #5 : SEMICOLON is relocated because \n can be placed between query implementation and semicolon*/
    {
      printMessage(q);
    }
  )+
}

int query() throws Exception: // #4 Query :<CREATE TABLE QUERY>| <DROP TABLE QUERY>| <DESC QUERY>| <SELECT QUERY>| <INSERT QUERY>| <DELETE QUERY>| <SHOW TABLES QUERY>
{
  int q; // used for switch statement.
}
{
  (
    (
      createTableQuery()
      {
        q = PRINT_CREATE_TABLE;
      }
  	)
  	|
 	(
  	  dropTableQuery()
  	  {
  	    q = PRINT_DROP_TABLE;
 	  }
 	)
	|
	(
	  descQuery()
	  {
	    q = PRINT_DESC;
	  }
	)
	|
	(
	  showTablesQuery()
	  {
	    q = PRINT_SHOW_TABLES;
	  }
	)
	|
	(
	  selectQuery()
	  {
	    q = PRINT_SELECT;
	  }
	)
	|
	(
	  insertQuery()
	  {
	    q = PRINT_INSERT;
	  }
	)
	|
	(
	  deleteQuery()
	  {
	    q = PRINT_DELETE;
	  }
	)       
  )
  (
    {
      return q;
    }
  )
}

/////////// delete rules ///////////
/*

<DELETE QUERY> ::= delete from <TABLE NAME> [<WHERE CLAUSE>]

*/

void deleteQuery() throws Exception:
{
  String keyString;
  Table retrievedTable=null;
  ArrayList<String> boolTestResults=null;
  int succCount =0;
  int failCount =0;
}
{
  < DELETE >
  < FROM >
  keyString = tableName()
  {
	// get table object from db
    DatabaseEntry theKey = null;
	try {
		theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
	} catch (UnsupportedEncodingException e) {
		e.printStackTrace();
	}
    DatabaseEntry theData = new DatabaseEntry();
    if(!getTableFromDB(theKey, theData)) // not found
    {
      throw new Exception("No such table");
    }
    else // found
    {
      currFromTables = new ArrayList<String>();
      currFromTables.add(keyString);
      currOriginalNames = new ArrayList<String>(currFromTables);
	  retrievedTable = (Table) entryBinding.entryToObject(theData);
    }
  }
  (
	boolTestResults = whereClause(retrievedTable.getRecords())
  )?
  < SEMICOLON >
  {
	// constraints 확인


	// booltestResults 보면서 언노운 빼주고 트루인애들만 남기기
	if(boolTestResults == null)
	  boolTestResults = new ArrayList<String>(Collections.nCopies(retrievedTable.getRecords().size(), "true"));
	ArrayList<ArrayList<String>> retrievedRecords = retrievedTable.getRecords();
	ArrayList<ArrayList<String>> newRecords = new ArrayList<ArrayList<String>>();
	for(int i=0;i<retrievedRecords.size();i++)
	{
	  if(!boolTestResults.get(i).equals("true")) // true 이면 지우고 false거나 unknown이면 살린다
	    newRecords.add(retrievedRecords.get(i));
	  else
	  {
	    // 지워도 되는지 : 1. 이걸 레코드를 쪼는 레코드가 없거나 2. 이걸 쪼는 레코드가 있는데 nullable일때
	   	if(retrievedTable.canBeDeleted(retrievedRecords.get(i))) // retrievedRecords.get(i)얘를 지워도 되는지 안되는지 확인 
		{
		  succCount++; // 지워도 되면 지우고
		  retrievedTable.makeReferencingRecordsNull(retrievedRecords.get(i));
		}
		else // 지울수 없으면
		{
		  newRecords.add(retrievedRecords.get(i)); // 살리고
		  failCount++; // 카운트 업
		}
	  }
	}	

	//retrievedTable에 whereClause 결과로 나온 레코드 셋 교체 해주면 됨
	retrievedTable.setRecord(newRecords);
	entryBinding.objectToEntry(retrievedTable,theData); 
	myDatabase.put(null, theKey, theData); // overwrite updated record
	myDatabase.sync();

	System.out.println(Integer.toString(succCount)+" row(s) are deleted");
	if(failCount > 0)
	  	System.out.println(Integer.toString(failCount)+" row(s) are not deleted due to referential integrity");
	return;
  }
}

/////////// insert rules ////////////////
/*

<INSERT QUERY> ::= insert into <TABLE NAME> <INSERT COLUMNS AND SOURCE>
<INSERT COLUMNS AND SOURCE> ::= [<COLUMN NAME LIST>] <VALUE LIST>
<VALUE LIST> ::= values <LEFT PAREN> <VALUE> (<COMMA> <VALUE>)* <RIGHT PAREN>
<VALUE> ::= null
| <COMPARABLE VALUE>

*/
void insertQuery() :
{
  String keyString;
  Pair<ArrayList<String>, ArrayList<String>> colsAndVals;
}
{
  < INSERT >
  < INTO >
  keyString = tableName()
  colsAndVals = insertColumnsAndSource()
  < SEMICOLON >
  {
	// get table object from db
    DatabaseEntry theKey = null;
	try {
		theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
	} catch (UnsupportedEncodingException e) {
		e.printStackTrace();
	}
	ArrayList<String> queryColNames = colsAndVals.getLeft();
	ArrayList<String> queryValues = colsAndVals.getRight();
	
    DatabaseEntry theData = new DatabaseEntry();
    if(!getTableFromDB(theKey, theData)) // not found
    {
      System.out.println("No such table");
      return;
    }
    else // found
    {
      /* 에러 케이스
      	타입이 맞지 않을때.
      	컬럼과 값의 수나 타입이 맞지 않는 경우,
       	컬럼을 명시하지 않았을 때 값의 수가 해당 테이블의 attribute 수와 같지 않은 경우에도 이 에러에 해당됨
       */
	  Table retrievedTable = (Table) entryBinding.entryToObject(theData);
	  ArrayList<Attribute> definedAttrs = retrievedTable.getAttrs();
	  
	  ArrayList<String> resultRecord;
	  ArrayList<Pair<String,String >> beforeSorting = new ArrayList<Pair<String,String >>();
	  
// 쿼리에 컬럼 네임을 줬고,
	  if(queryColNames != null)
	  {
	    // 쿼리 컬럼과 값의 수가 맞지 않을때
		if(queryColNames.size() != queryValues.size())
		{
	      System.out.println("Insertion has failed: Types are not matched");
	      return;
	    }
	    if(checkDup(queryColNames)) // 쿼리 col name이 중복된 쿼리
	    {
	      System.out.println("Insertion has failed: Types are not matched");
	      return;
	    }
	    if(queryColNames.size() != definedAttrs.size()) // db에 정의된 컬럼 수랑 쿼리 컬럼 수 비교
	    {
	      System.out.println("Insertion has failed: Types are not matched");
	      return;
	    }
		  
		// 존재하지 않는 컬럼에 값을 삽입하려고 할 경우 	    
		// 컬럼과 값의 타입이 맞지 않응때
		int i = 0;
		for(String cursor : queryColNames)
		{
		  Attribute foundAttr = retrievedTable.getAttributeByName(cursor); 
		  if(foundAttr == null) // 쿼리 컬럼이 정의 안돼있을때
		  {
		    System.out.println("Insertion has failed: '"+cursor+"' does not exist");
		    return;
		  }
		  String currQueryVal = queryValues.get(i); // int@123151 , char@'sdfsdf', null@null
		  String queryValType = currQueryVal.split("@",2)[0];
		  String queryVal = currQueryVal.split("@",2)[1];
		  Boolean nullable = foundAttr.getNullable();

		  if(!foundAttr.getType().equals(queryValType)) // type이 맞지 않으면
		  {
		    if(queryValType.equals("null"))
		    { }
			else if(!(foundAttr.getType().startsWith("char") && queryValType.equals("char")))
			{
			  System.out.println("Insertion has failed: Types are not matched");
	          return;
			}
		  }
		  
		  if(queryVal.equals("null") && (!nullable)) // nullable 하지 않은 컬럼에 null 넣으면
		  {
			System.out.println("Insertion has failed: '"+cursor+"' is not nullable");
	        return;
		  }

		  // char 자르기
		  if(queryValType.equals("char"))
		  {
		    int size = Integer.parseInt(foundAttr.getType().substring(5,foundAttr.getType().length()-1));
			queryVal = removeQuote(queryVal); // ' 없에기
			if(queryVal.length() > size)
			  queryVal = queryVal.substring(0,size);		    
		  }

		  // 실제 테이블의 컬럼 인덱스와 쿼리받은 벨류 페어로 일단 저장 후 나중에 실제 테이블 컬럼 순으로 벨류 정렬
		  beforeSorting.add(new Pair<String,String>(Integer.toString(definedAttrs.indexOf(foundAttr)),queryVal));
		  
		  i++;
		}
	  }
// 쿼리에 컬럼 네임을 안줬고,
	  else
	  {
		if(queryValues.size() != definedAttrs.size()) // db에 정의된 컬럼 수랑 쿼리 컬럼 수 비교
	    {
	      System.out.println("Insertion has failed: Types are not matched");
	      return;
	    }

		// 존재하지 않는 컬럼에 값을 삽입하려고 할 경우 	    
		// 컬럼과 값의 타입이 맞지 않응때
		int i = 0;
		for(Attribute cursor : definedAttrs)
		{
		  String currQueryVal = queryValues.get(i); // int@123151 , char@'sdfsdf', null@null
		  String queryValType = currQueryVal.split("@",2)[0];
		  String queryVal = currQueryVal.split("@",2)[1];
		  Boolean nullable = cursor.getNullable();

		  if(!cursor.getType().equals(queryValType)) // type이 맞지 않으면
		  {
		    if(queryValType.equals("null"))
		    { }
			else if(!(cursor.getType().startsWith("char") && queryValType.equals("char")))
			{
			  System.out.println("Insertion has failed: Types are not matched");
	          return;
			}
		  }
		  
		  if(queryVal.equals("null") && (!nullable)) // nullable 하지 않은 컬럼에 null 넣으면
		  {
			System.out.println("Insertion has failed: '"+cursor.getAttrName()+"' is not nullable");
	        return;
		  }

		  // char 자르기
		  if(queryValType.equals("char"))
		  {
		    int size = Integer.parseInt(cursor.getType().substring(5,cursor.getType().length()-1));
			queryVal = removeQuote(queryVal); // ' 없에기
			if(queryVal.length() > size)
			  queryVal = queryVal.substring(0,size);		    
		  }

		  // 실제 테이블의 컬럼 인덱스와 쿼리받은 벨류 페어로 일단 저장 후 나중에 실제 테이블 컬럼 순으로 벨류 정렬
		  beforeSorting.add(new Pair<String,String>(Integer.toString(i),queryVal));
		  
		  i++;
		}
	    
	  }

 // 정렬해서 record에 넣어주기
 	  resultRecord = new ArrayList<String>(Collections.nCopies(beforeSorting.size(), ""));
	  for(Pair<String,String> cursor : beforeSorting)
	  {
	    resultRecord.set(Integer.parseInt(cursor.getLeft()),cursor.getRight());
	  }
//primary key 제약에 위배된다면
	  if(!retrievedTable.checkPrimaryConstraint(resultRecord))
	  {
	    System.out.println("Insertion has failed: Primary key duplication");
	    return;
	  }
//결과가 foreign key 제약에 위배된다면 : foreign key 하나씩 돌면서 foreign key attr 인덱스 표시하고 해당 테이블의 레코드 가져와서
// 그 테이블의 foreign key attr 표시해서 쭉 비교
	  if(!retrievedTable.checkForeignConstraint(resultRecord))
	  {
		System.out.println("Insertion has failed: Referential integrity violation");
	    return;
	  }
	  ArrayList<ArrayList<String>> retrievedRecords = retrievedTable.getRecords();
	  retrievedRecords.add(resultRecord);
	  retrievedTable.setRecord(retrievedRecords);
	  	 
	  entryBinding.objectToEntry(retrievedTable,theData); 
	  myDatabase.put(null, theKey, theData); // overwrite updated record
	  myDatabase.sync();

	  System.out.println("The row is inserted");
	  return;
    }

  }
}

Pair<ArrayList<String>, ArrayList<String>> insertColumnsAndSource() :
{
  ArrayList<String> valList;
  ArrayList<String> colNameList=null;
}
{
  (
    colNameList = columnNameList()
  )?
  valList = valueList()
  {
	return (new Pair<ArrayList<String>, ArrayList<String>>(colNameList, valList));
  }
}

ArrayList<String> valueList() :
{
  ArrayList<String> result = new ArrayList<String>();
  String val;
}
{
  < VALUES >
  < LEFT_PAREN >
  val = value()
  {
	result.add(val);
  }
  (
	< COMMA >
	val = value()
	{
	  result.add(val);
	}
  )*
  < RIGHT_PAREN >
  {
	return result;
  }
}

String value() :
{
  String result;
}
{
  < NULL >
  {
	return "null@null";
  }
| result = comparableValue()
  {
	return result;
  }
}

/////////// select rules /////////////////
/*

<SELECT QUERY> ::= select <SELECT LIST> <TABLE EXPRESSION>
<SELECT LIST> ::= *
| <SELECTED COLUMN> (<COMMA> <SELECTED COLUMN>)*
<SELECTED COLUMN> ::= [<TABLE NAME> <PERIOD>] <COLUMN NAME> [as <COLUMN NAME>]
<PERIOD> ::= .
<TABLE EXPRESSION> ::= <FROM CLAUSE> [<WHERE CLAUSE>]
<FROM CLAUSE> ::= from <TABLE REFERENCE LIST>
<TABLE REFERENCE LIST> ::= <REFERED TABLE> (<COMMA> <REFERED TABLE>)*
<REFERED TABLE> ::= <TABLE NAME> [as <TABLE NAME>]
<WHERE CLAUSE> ::= where <BOOLEAN VALUE EXPRESSION>
<BOOLEAN VALUE EXPRESSION> ::= <BOOLEAN TERM> ( or <BOOLEAN TERM>)*
<BOOLEAN TERM> ::= <BOOLEAN FACTOR>( and <BOOLEAN FACTOR> )*
<BOOLEAN FACTOR> ::= [not] <BOOLEAN TEST>
<BOOLEAN TEST> ::= <PREDICATE>
| <PARENTHESIZED BOOLEAN EXPRESSION>
<PARENTHESIZED BOOLEAN EXPRESSION> ::= <LEFT PAREN> <BOOLEAN VALUE EXPRESSION> <RIGHT PAREN>
<PREDICATE> ::= <COMPARISON PREDICATE>
| <NULL PREDICTE>
<COMPARISON PREDICATE> ::= <COMP OPERAND> <COMP OP> <COMP OPERAND>
<COMP OPERAND> ::= <COMPARABLE VALUE>
| [<TABLE NAME> <PERIOD>] <COLUMN NAME>
<COMP OP> ::= < | > | = | >= | <= | !=
<COMPARABLE VALUE> ::= <INT VALUE>
| <CHAR STRING>
| <DATE VALUE>
<NULL PREDICATE> ::= [<TABLE NAME> <PERIOD>] <COLUMN NAME> <NULL OPERATION>
<NULL OPERATION> ::= is [not] null

*/
void selectQuery() throws Exception :
{
  ArrayList<String> selectedColList;
  ArrayList<ArrayList<String>> filteredRecords;
}
{
  < SELECT >
  selectedColList = selectList()
  {
    // from절로 넘어가기 전에 이거 초기화
	currFromTables = new ArrayList<String>();
    currOriginalNames = new ArrayList<String>();
  }
  filteredRecords = tableExpression()  
  < SEMICOLON >
  {
	// selectedColList 체크 - > empty면 *임, 각 colname 형식은 tablename@colname@newcolname
	// tablename.col as rename 
	// 모호함 체크
	ArrayList<Pair<String,Integer>> printColNameAndIndex = new ArrayList<Pair<String,Integer>>();
	if(selectedColList.isEmpty()) // * 일때 : 안모호함
	{
		// 출력할 컬럼들을 모든 컬럼들로
	  int i = 0;
	  for(String cursor : currOriginalNames)
	  {
	     // get table object from db
		DatabaseEntry theKey = null;
		try {
			theKey = new DatabaseEntry(cursor.getBytes("UTF-8"));
		} catch (UnsupportedEncodingException e) {e.printStackTrace();}
		DatabaseEntry theData = new DatabaseEntry();
		if(!getTableFromDB(theKey, theData)) // not found
		{
		  System.out.println("select : can not reach here");
		}
		else // found
		{     
	 	  Table retrievedTable = (Table) entryBinding.entryToObject(theData);
	 	  for(Attribute attrCursor : retrievedTable.getAttrs())
	 	  {
			printColNameAndIndex.add(new Pair<String,Integer>(attrCursor.getAttrName(),i));
			i++;
	 	  }
	 	}	 
	  }
	}
	else
	{
	  
	  for(String cursor : selectedColList)
	  {
	    String[] parsedCursor = cursor.split("@");
	    String tableName = parsedCursor[0];
	    String colName = parsedCursor[1];
	    String newColName = parsedCursor[2];
	    Integer fromIndex = 0;

	    if(tableName.equals("")) // 테이블 네임 명시 안했을때
	    {
	      Boolean checkAm = false;
	      int i = 0;
	      for(String fromCursor : currOriginalNames)
	      {
			 // get table object from db
		    DatabaseEntry theKey = null;
			try {
				theKey = new DatabaseEntry(fromCursor.getBytes("UTF-8"));
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
			}
		    DatabaseEntry theData = new DatabaseEntry();
		    if(!getTableFromDB(theKey, theData)) // not found
		    {
		      System.out.println("select : can not reach here");
		    }
		    else // found
		    {     
	 	      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
	 	      if(retrievedTable.containsAttr(colName))
	 	      {
				if(checkAm) // 이미 한번 나왔었다면
				{
				  throw new Exception("Selection has failed: fail to resolve '"+colName+"'");
				}
				checkAm = true;
				fromIndex = i;
	 	      }
	 	    }
	 	    i++;
	      }
	      if(!checkAm) // 다 돌동안 한번도 안나왔다면
	      {
		    throw new Exception("Selection has failed: fail to resolve '"+colName+"'");
	      }
	      // 모호하지 않다
	    }
	    else // 테이블네임 명시했을때
	    {
		  Boolean checkAm = false;
		  int j=0;
	      for(String fromCursor : currFromTables)
	      {
	        if(fromCursor.equalsIgnoreCase(tableName))
	        {
	          if(checkAm) // from절에 같은이름 두개이상있을때
	          {
				throw new Exception("Selection has failed: fail to resolve '"+colName+"'");
	          }
	          checkAm = true;
	          fromIndex = j;
	        }
	        j++;
	      }
	      if(!checkAm) // 테이블네임이 프롬절에 없다
	      {
		    throw new Exception("Selection has failed: fail to resolve '"+colName+"'");
	      }
	       // get table object from db
		  DatabaseEntry theKey = null;
		  try {
				theKey = new DatabaseEntry(currOriginalNames.get(fromIndex).getBytes("UTF-8"));
		  } catch (UnsupportedEncodingException e) {e.printStackTrace();}
		  DatabaseEntry theData = new DatabaseEntry();
		  if(!getTableFromDB(theKey, theData)) // not found
		  {
		    System.out.println("select : can not reach here");
		  }
		  else // found
		  {     
	 	    Table retrievedTable = (Table) entryBinding.entryToObject(theData);
	 	    if(!retrievedTable.containsAttr(colName)) // 해당 테이블이 컬럼을 포함 안하면
	 	    {
			  throw new Exception("Selection has failed: fail to resolve '"+colName+"'");
	 	    }
	 	  }
	      
	    }
	    // 모호하지 않다
	    // 여기서 페어 만들어야함
	    if(newColName.equals("null"))
	      printColNameAndIndex.add(new Pair<String,Integer>(colName,getColIndexAndType(fromIndex,colName).getLeft()));
		else
	      printColNameAndIndex.add(new Pair<String,Integer>(newColName,getColIndexAndType(fromIndex,colName).getLeft()));
	  }
	  
	}
	// 여기서 출력하자

//+----------------+-------------+---------+
//| ACCOUNT_NUMBER | BRANCH_NAME | BALANCE |
//+----------------+-------------+---------+
//| A-101          | Downtown    | 500     |

    for(Pair<String,Integer> cursor : printColNameAndIndex)
    {
	  System.out.print("+");
	  printIter("-",cursor.getLeft().length()+12);
    }
    System.out.println("+");

    for(Pair<String,Integer> cursor : printColNameAndIndex)
    {
	  System.out.print("|");
	  printIter(" ",6);
	  System.out.print(cursor.getLeft().toUpperCase());
	  printIter(" ",6); 
    }
    System.out.println("|");

    for(Pair<String,Integer> cursor : printColNameAndIndex)
    {
	  System.out.print("+");
	  printIter("-",cursor.getLeft().length()+12);
    }
    System.out.println("+");

    Boolean temp=false;
    for(ArrayList<String> recCursor : filteredRecords)
    {
	  for(Pair<String,Integer> cursor : printColNameAndIndex)
      {
	    System.out.print("|");
	    printIter(" ",1);
	    System.out.print(recCursor.get(cursor.getRight()));
	    printIter(" ",11+(cursor.getLeft().length()-recCursor.get(cursor.getRight()).length()));
      }
      System.out.println("|");
      temp = true;
    }
    if(temp)
    { 
      for(Pair<String,Integer> cursor : printColNameAndIndex)
      {
	    System.out.print("+");
	    printIter("-",cursor.getLeft().length()+12);
      }
      System.out.println("+");
    }
    
	
  }
}

ArrayList<String> selectList() throws Exception :
{
  ArrayList<String> result = new ArrayList<String>();
  String temp;
}
{
  < ASTERISK >
  {
	return result;
  }
| (
    temp = selectedColumn()
    {
	  result.add(temp);
    }
    (
      < COMMA >
      temp = selectedColumn()
      {
		result.add(temp);
      }
    )*
  )
  {
	return result;
  }
}

String selectedColumn() throws Exception :
{
  String tableName = "";
  String rename = "null";
  String colName = "";
}
{
  (     (
    LOOKAHEAD(2) //#7 choice confilict, <LEGAL_IDENTIFIER>.... using LOOKAHEAD, solve this.
    tableName = tableName()
    < PERIOD >
    )?
    colName = columnName()
    (
   	  < AS >
	  rename = columnName()
    )?
  )
  {
	return tableName+"@"+colName+"@"+rename;
  }
}

ArrayList<ArrayList<String>> tableExpression() throws Exception :
{
  ArrayList<ArrayList<String>> productedRecords;
  ArrayList<String> boolTestResults=null;
}
{
  (    
  productedRecords = fromClause() // 프롬절의 테이블이름들은 전역으로 저장되었고
  (
    boolTestResults = whereClause(productedRecords)
  )?

  )
  {
	if(boolTestResults == null) // where절이 없으면
	  boolTestResults = new ArrayList<String>(Collections.nCopies(productedRecords.size(), "true"));

	ArrayList<ArrayList<String>> newRecords = new ArrayList<ArrayList<String>>();
	for(int i=0;i<productedRecords.size();i++)
	{
	  if(boolTestResults.get(i).equals("true")) // true 이면 남긴다
	    newRecords.add(productedRecords.get(i));
	}
	// 여기서 정리 조져서 리턴
	return newRecords;
  }
}

ArrayList<ArrayList<String>> fromClause() throws Exception :
{
  ArrayList<ArrayList<String>> result;
}
{
  < FROM >
  result = tableReferenceList()
  {
	return result;
  }
}

ArrayList<ArrayList<String>> tableReferenceList() throws Exception :
{
  ArrayList<ArrayList<String>> result;
  ArrayList<ArrayList<String>> additional;
}
{
  (    
  result = referedTable()
  (
	< COMMA >
	additional = referedTable()
	{
	  result = carteProduct(result, additional);
	}
  )*

  )
  {
	return result;
  }
  
}

ArrayList<ArrayList<String>> referedTable() throws Exception: // pair로 리턴? 스트링으로 리턴? 리턴 안해도?, 이 안에서 카테시안 프로덕트 진행해야할듯
{
  String keyString;
  String newName;
  ArrayList<ArrayList<String>> result;
}
{
	(    
	  keyString = tableName()
	  {
		// get table object from db
	    DatabaseEntry theKey = null;
		try {
			theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
	    DatabaseEntry theData = new DatabaseEntry();
	    if(!getTableFromDB(theKey, theData))// not found
	    	throw new Exception("Selection has failed: '"+keyString+"' does not exist");
	    else // found
		{     
		  Table retrievedTable = (Table) entryBinding.entryToObject(theData);
		  result = retrievedTable.getRecords();
		// select 쿼리함수에서 currFromTables랑 currOriginalNames를 그냥 할당하고
		// 여기서 add 하는식으로?
		  currFromTables.add(keyString);
		  currOriginalNames.add(keyString);
		}
	  }
	  (
		< AS >
		newName = tableName()
		{
		  currFromTables.set(currFromTables.size()-1,newName);
		}
	  )?
	)
	{
	  return result;
	}
}

ArrayList<String> whereClause(ArrayList<ArrayList<String>> records) throws Exception :
{
  ArrayList<String> result;
}
{
  < WHERE >
  result = booleanValueExpression(records)
  {
	return result;
  }
}

ArrayList<String> booleanValueExpression(ArrayList<ArrayList<String>> records) throws Exception :
{
  ArrayList<String> result,additional;
}
{
  result = booleanTerm(records)
  (
    < OR >
    additional = booleanTerm(records)
    {
      for(int i=0;i<result.size();i++)
      { 
        if(result.get(i).equals("unknown"))
        {
          if(additional.get(i).equals("true"))
            result.set(i,"true");
          else
            result.set(i,"unknown");
        }
        else if(additional.get(i).equals("unknown"))
        {
          if(result.get(i).equals("true"))
            result.set(i,"true");
          else
		    result.set(i,"unknown");
        }
        else
          result.set(i,String.valueOf(Boolean.valueOf(result.get(i)) || Boolean.valueOf(additional.get(i)))); // 둘 다 언노운이 아니면
	  }
    }
  )*
  {
	return result;
  }
}

ArrayList<String> booleanTerm(ArrayList<ArrayList<String>> records) throws Exception :
{
  ArrayList<String> result,additional;
}
{
  result = booleanFactor(records)
  (
    < AND >
    additional = booleanFactor(records)
    { 
	    for(int i=0;i<result.size();i++)
	    { 
	        if(result.get(i).equals("unknown"))
	        {
	          if(additional.get(i).equals("false"))
	            result.set(i,"false");
	          else
	            result.set(i,"unknown");
	        }
	        else if(additional.get(i).equals("unknown"))
	        {
	          if(result.get(i).equals("false"))
	            result.set(i,"false");
	          else
			    result.set(i,"unknown");
	        }
	        else
	          result.set(i,String.valueOf(Boolean.valueOf(result.get(i)) && Boolean.valueOf(additional.get(i)))); // 둘 다 언노운이 아니면
		}
	}
  )*
  {
	return result;
  }
}

ArrayList<String> booleanFactor(ArrayList<ArrayList<String>> records) throws Exception :
{
  ArrayList<String> result;
  Boolean isNot = false;  
}
{
  (
    < NOT >
    {
      isNot = true;
    }
  )?
  result = booleanTest(records)
  {
    for(int i=0;i<result.size();i++)
    { 
	  if(isNot)
	  {
	    if(!result.get(i).equals("unknown"))
	      result.set(i,String.valueOf(!Boolean.valueOf(result.get(i))));
	  }
	}
	return result;
  }
}

ArrayList<String> booleanTest(ArrayList<ArrayList<String>> records) throws Exception :
{
  ArrayList<String> result;
}
{
  (    result = predicate(records)
| result = parenthesizedBooleanExpression(records)
  )
  {
	return result;
  }
}

ArrayList<String> parenthesizedBooleanExpression(ArrayList<ArrayList<String>> records) throws Exception :
{
  ArrayList<String> result;
}
{
  < LEFT_PAREN >
  result = booleanValueExpression(records)
  < RIGHT_PAREN >
  {
	return result;
  }
}

ArrayList<String> predicate(ArrayList<ArrayList<String>> records) throws Exception :
{
  ArrayList<String> result;
}
{
  (    LOOKAHEAD(4) // #8 choice conflict <LEGAL_IDENTIFIER> <PERIOD> ... , to solve this, use LOOKAHEAD(3)    result = comparisonPredicate(records)
| result = nullPredicate(records)
)
  {
	return result;
  }
}

ArrayList<String> comparisonPredicate(ArrayList<ArrayList<String>> records) throws Exception :
{
  String leftOperand,rightOperand,op;
  String boolTemp;
  ArrayList<String> result = new ArrayList<String>(Collections.nCopies(records.size(),""));
}
{
  leftOperand = compOperand() // "tableindex@col name" or "type@value"
  op = compOp() //  "<" | ">" | "=" | "<=" | ">=" | "!=" 
  rightOperand = compOperand()
  {
	String leftType = leftOperand.split("@",2)[0];
	String leftVal = leftOperand.split("@",2)[1];
	String rightType = rightOperand.split("@",2)[0];
	String rightVal = rightOperand.split("@",2)[1];
	if(leftType.equals("char"))
	  leftVal = removeQuote(leftVal);
	if(rightType.equals("char"))
	  rightVal = removeQuote(rightVal);

	if(isType(leftType) && isType(rightType)) // 상수비교 명제
	{
	  // 두 상수의 타입이 같을때
	  if(leftType.equals(rightType)) 
	  {
		boolTemp = compareTwoValues(leftVal,op,rightVal,leftType.equals("int")); // 명제가 참이면 항상 참(상수)
		for(int i=0;i<result.size();i++)
		{
		  result.set(i,boolTemp);
		}
		return result;
	  }
	  else // 두 상수의 타입이 다를 때
	  {
	    throw new Exception("Where clause try to compare incomparable values");
	  }
	}
	else if(isType(rightType)) // 왼쪽 변수 오른쪽 상수 , leftType : table index, left Val : col name
	{
	  Pair<Integer, String> leftIndexAndType = getColIndexAndType(Integer.parseInt(leftType),leftVal);
	  if(leftIndexAndType.getRight().startsWith(rightType)) // 둘의 타입이 같다면
	  {
	    for(int i=0;i<result.size();i++)
	    {
		  result.set(i,compareTwoValues(records.get(i).get(leftIndexAndType.getLeft()),op,rightVal,rightType.equals("int")));
	    }
		return result;
	  }
	  else// 타입이 다르다면
	  {
	    throw new Exception("Where clause try to compare incomparable values");
	  }
	}
	else if(isType(leftType)) // 왼쪽 상수 오른쪽 변수
	{
	  Pair<Integer, String> rightIndexAndType = getColIndexAndType(Integer.parseInt(rightType),rightVal);
	  if(rightIndexAndType.getRight().startsWith(leftType)) // 둘의 타입이 같다면
	  {
	    for(int i=0;i<result.size();i++)
	    {
		  result.set(i,compareTwoValues(leftVal,op,records.get(i).get(rightIndexAndType.getLeft()),leftType.equals("int")));
		}
		return result;
	  }
	  else// 타입이 다르다면
	  {
	    throw new Exception("Where clause try to compare incomparable values");
	  }
	}
	else // 둘다 변수
	{
	  Pair<Integer, String> leftIndexAndType = getColIndexAndType(Integer.parseInt(leftType),leftVal);
	  Pair<Integer, String> rightIndexAndType = getColIndexAndType(Integer.parseInt(rightType),rightVal);
	  if(rightIndexAndType.getRight().equals(leftIndexAndType.getRight())
	  	|| (rightIndexAndType.getRight().startsWith("char") && leftIndexAndType.getRight().startsWith("char"))) // 둘의 타입이 같다면
	  {
	    for(int i=0;i<result.size();i++)
	    {
		  result.set(i,compareTwoValues(records.get(i).get(leftIndexAndType.getLeft()),op,records.get(i).get(rightIndexAndType.getLeft()),leftIndexAndType.getRight().equals("int")));
		}
		return result;
	  }
	  else// 타입이 다르다면
	  {
	    throw new Exception("Where clause try to compare incomparable values");
	  }
	}
  }
}

String compOperand() throws Exception :
{
  String result, queryTableName = "";
  Boolean temp = false;
  int index = 0;
}
{
  result = comparableValue()
  {
	return result;
  }
| (
    (
      LOOKAHEAD(2) //#7
      queryTableName = tableName()
      < PERIOD >
      {
          if(!containsCaseInsen(currFromTables, queryTableName))// from clause does not contains
		  { 
	    	  throw new Exception("Where clause try to reference tables which are not specified");
		  }
      }
    )?
    result = columnName()
    {
	  if(queryTableName.equals("")) // 쿼리에서 테이블 네임 명시 안했을때
	  {
	    int i = 0;
		for(String tableNameCursor : currOriginalNames) // 프롬절 테이블들 다 돌면서 있는지 확인, 모호한지 확인
		{
		  // get table object from db
		    DatabaseEntry theKey = null;
			try {
				theKey = new DatabaseEntry(tableNameCursor.getBytes("UTF-8"));
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
			}
		    DatabaseEntry theData = new DatabaseEntry();
		    if(!getTableFromDB(theKey, theData)) // not found
		    {
		      System.out.println("compOperand : can not reach here");
		    }
		    else // found
		    {     
	 	      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
	 	      if(retrievedTable.containsAttr(result)) 
	 	      {
				if(temp) // 이미 다른 테이블에 이 컬럼과 같은 이름이 존재 : 모호함
				{
				        throw new Exception("Where clause contains ambiguous reference");
				}
				else
				{
				  temp = true;
				  index = i;
				}	
	 	      }
	   		}
	   		i++;
		}
		if(!temp) // 이 컬럼을 포함하는 테이블이 하나도 없으면
		{
		        throw new Exception("Where clause try to reference non existing column");
		}
	  }
	  else // 쿼리에서 테이블 네임 명시 했을때
	  {
	    // 명시한 테이블의 attrs중에 이 콜롬네임이 있는지 확인
		// 모호함 확인
		Boolean checkAm = false;
		int i=0;
		for(String cursor : currFromTables)
		{
		  if(cursor.equalsIgnoreCase(queryTableName))
		  {
			if(checkAm) // from절에 같은 테이블 이름 존재
			{
				        throw new Exception("Where clause contains ambiguous reference");
			}
			checkAm = true;
			index = i;
		  }
		  i++;
		}
	    
	    // get table object from db
	    DatabaseEntry theKey = null;
		try {
			theKey = new DatabaseEntry(currOriginalNames.get(index).getBytes("UTF-8"));
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
	    DatabaseEntry theData = new DatabaseEntry();
	    if(!getTableFromDB(theKey, theData)) // not found
	    {
	      System.out.println("compOperand : can not reach here");
	    }
	    else // found
	    {     
 	      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
 	      if(!retrievedTable.containsAttr(result)) // 명시한 테이블이 이 컬럼을 포함 안하면
 	      {
		        throw new Exception("Where clause try to reference non existing column");
 	      }
   		}  
	  }

	  queryTableName = Integer.toString(index) + "@";
    }
  )
  {
	return queryTableName + result; // "tab index"+"@"+"colname"
  }
}

String compOp() :
{
  Token signs;
}
{
  signs = < COMPARISON_SIGNS >
  {
	return signs.image;
  }
}

String comparableValue() :
{
  Token result;
}
{
  result = < INT_VALUE >
  {
	return "int@"+result.image;
  }
| result = < CHAR_STRING >
  {
	return "char@"+result.image;
  }
| result = < DATE_VALUE >
  {
	return "date@"+result.image;
  }

}

ArrayList<String> nullPredicate(ArrayList<ArrayList<String>> records) throws Exception :
{
  String result, queryTableName = "";
  ArrayList<String> boolResults = new ArrayList<String>(Collections.nCopies(records.size(),""));
  Boolean temp = false;
  Boolean isNot = false;
  int index = 0;
}
{
  
  (
    LOOKAHEAD(2) //#7
	queryTableName = tableName()
	< PERIOD >
	{
      if(!containsCaseInsen(currFromTables, queryTableName))// from clause does not contains
	  { 
	    throw new Exception("Where clause try to reference tables which are not specified");
	  }
    }
  )?
  result = columnName()
  {
	  if(queryTableName.equals("")) // 쿼리에서 테이블 네임 명시 안했을때
	  {
	    int i = 0;
		for(String tableNameCursor : currOriginalNames) // 프롬절 테이블들 다 돌면서 있는지 확인, 모호한지 확인
		{
		  // get table object from db
		    DatabaseEntry theKey = null;
			try {
				theKey = new DatabaseEntry(tableNameCursor.getBytes("UTF-8"));
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
			}
		    DatabaseEntry theData = new DatabaseEntry();
		    if(!getTableFromDB(theKey, theData)) // not found
		    {
		      System.out.println("NullPredicate : can not reach here");
		    }
		    else // found
		    {     
	 	      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
	 	      if(retrievedTable.containsAttr(result)) 
	 	      {
				if(temp) // 이미 다른 테이블에 이 컬럼과 같은 이름이 존재 : 모호함
				{
				        throw new Exception("Where clause contains ambiguous reference");
				}
				else
				{
				  temp = true;
				  index = i;
				}	
	 	      }
	   		}
	   		i++;
		}
		if(!temp) // 이 컬럼을 포함하는 테이블이 하나도 없으면
		{
		        throw new Exception("Where clause try to reference non existing column");
		}
	  }
	  else // 쿼리에서 테이블 네임 명시 했을때
	  {
	    // 명시한 테이블의 attrs중에 이 콜롬네임이 있는지 확인
		// 모호함 확인
		Boolean checkAm = false;
		int i=0;
		for(String cursor : currFromTables)
		{
		  if(cursor.equalsIgnoreCase(queryTableName))
		  {
			if(checkAm) // from절에 같은 테이블 이름 존재
			{
				        throw new Exception("Where clause contains ambiguous reference");
			}
			checkAm = true;
			index = i;
		  }
		  i++;
		}
	    
	    // get table object from db
	    DatabaseEntry theKey = null;
		try {
			theKey = new DatabaseEntry(currOriginalNames.get(index).getBytes("UTF-8"));
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
	    DatabaseEntry theData = new DatabaseEntry();
	    if(!getTableFromDB(theKey, theData)) // not found
	    {
	      System.out.println("NullPredicate : can not reach here");
	    }
	    else // found
	    {     
 	      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
 	      if(!retrievedTable.containsAttr(result)) // 명시한 테이블이 이 컬럼을 포함 안하면
 	      {
		        throw new Exception("Where clause try to reference non existing column");
 	      }
   		}  
	  }

	  queryTableName = Integer.toString(index) + "@";
	  result = queryTableName + result;
  }
  isNot = nullOperation()
  {
 // result : "tableindex@col name""
		String tableIndex = result.split("@",2)[0];
		String colName = result.split("@",2)[1];

	    Pair<Integer, String> indexAndType = getColIndexAndType(Integer.parseInt(tableIndex),colName);
		for(int i=0;i<boolResults.size();i++)
		{
		  if(isNot) // is not null 이면
		  {
		    if(!records.get(i).get(indexAndType.getLeft()).equals("null"))
		      boolResults.set(i,"true");
		    else
		      boolResults.set(i,"false");
		  }
		  else // is null 이면
		  {
			if(records.get(i).get(indexAndType.getLeft()).equals("null"))
			  boolResults.set(i,"true");
			else
			  boolResults.set(i,"false");
		  }
		}
		return boolResults;
  }
}

Boolean nullOperation() :
{
  Boolean isNot;
}
{
//  < IS >
//  (
//	< NOT >
//  )?
//  < NULL >  #9 this definition makes conflict with < NOT_NULL > token. 

  < IS >
  (
    < NOT_NULL >
    {
      isNot = true;
    }
  | < NULL >
    {
      isNot = false;
    }
  )
  {
	return isNot;
  }
}

/////////// show table rules ///////////
/*

<SHOW TABLES QUERY> ::= show tables

*/
void showTablesQuery() :
{}
{
  < SHOW >
  < TABLES >
  < SEMICOLON >
  {
	/* PRJ2 #3 : implementation of show tables */

	if (cursor.getFirst(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.NOTFOUND)
	{ // empty db case
	  System.out.println("There is no table");
	}
	else
	{
	  System.out.println("----------------");
	  do // traverse entire db
	  {     
	    String res_key = null;
	    try {
	   			res_key = new String(foundKey.getData(), "UTF-8");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
	    System.out.println(res_key);
	  } while (cursor.getNext(foundKey, foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);
	  System.out.println("----------------");
	}
  }
}

/////////// desc rules ////////////
/*

<DESC QUERY> ::= desc <TABLE NAME>

*/
// PRJ2 #11 : implementation of desc
void descQuery() :
{
  String keyString;
}
{
  < DESC >
  keyString = tableName()
  < SEMICOLON >
  {
    try { 
    // get table object from db
    DatabaseEntry theKey = null;
	try {
		theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
	} catch (UnsupportedEncodingException e) {
		e.printStackTrace();
	}
    DatabaseEntry theData = new DatabaseEntry();
    String attrName, attrType, attrNullable;
    if(!getTableFromDB(theKey, theData)) // not found
    {
      System.out.println("No such table");
    }
    else // found
    {     
      // the EntryBinding created above
      Table retrievedTable = (Table) entryBinding.entryToObject(theData);

	  System.out.println("-------------------------------------------------");
	  System.out.println("table_name ["+retrievedTable.getTableName()+"]");
	  System.out.printf("%-19s%-10s%-10s%-10s\n", "column_name","type","null","key");
	  
	  for(Attribute cursor : retrievedTable.getAttrs())
	  {
	    attrName = cursor.getAttrName();
	    attrType = cursor.getType();
	    if(cursor.getNullable())
	      attrNullable = "Y";
	    else
	      attrNullable = "N";
	    System.out.printf("%-19s%-10s%-10s%-10s\n", attrName, attrType, attrNullable, whatKey(retrievedTable, attrName));
	  }
	
	  System.out.println("-------------------------------------------------");
	}
	} catch (Exception e) { e.printStackTrace(); }

  }
}

/////////// drop table rules /////////////
/*

<DROP TABLE QUERY> ::= drop table <TABLE NAME>

*/

// PRJ2 #12 : implementation of drop table
void dropTableQuery() :
{
  String keyString;
}
{
  < DROP >
  < TABLE >
  keyString = tableName()
  < SEMICOLON >
  {
	// get table object from db
    DatabaseEntry theKey = null;
	try {
		theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
	} catch (UnsupportedEncodingException e) {
		e.printStackTrace();
	}
    DatabaseEntry theData = new DatabaseEntry();
    if(!getTableFromDB(theKey, theData)) // not found
    {
      System.out.println("No such table");
    }
    else // found
    {
      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
	  if(retrievedTable.isReferenced())
	  	System.out.println("Drop table has failed: '"+ keyString +"' is referenced by other table");
	  else
	  {
		deleteReference(retrievedTable); // delete this table from referencedBy list of other referenced table
		myDatabase.delete(null, theKey);
		myDatabase.sync();
		System.out.println("'"+ keyString +"' table is dropped");
	  }
    }

  }
}

/////////// create table rules ///////////////
/*

<CREATE TABLE QUERY> ::= create table <TABLE NAME> <TABLE ELEMENT LIST>
<TABLE ELEMENT LIST> ::= <LEFT PAREN> <TABLE ELEMENT> (<COMMA> <TABLE ELEMENT>)* <RIGHT PAREN>
<TABLE ELEMENT> ::= <COLUMN DEFINITION>
| <TABLE CONSTRAINT DEFINITION>
<COLUMN DEFINITION> ::= <COLUMN NAME> <DATA TYPE> [not null]
<TABLE CONSTRAINT DEFINITION> ::= <PRIMARY KEY CONSTRAINT>
| <REFERENTIAL CONSTRAINT>
<PRIMARY KEY CONSTRAINT> ::= primary key <COLUMN NAME LIST>
<REFERENTIAL CONSTRAINT> ::= foreign key <COLUMN NAME LIST> references <TABLE NAME> <COLUMN NAME LIST>
<COLUMN NAME LIST> ::= <LEFT PAREN> <COLUMN NAME> (<COMMA> <COLUMN NAME>)* <RIGHT PAREN>
<DATA TYPE> ::= int
| char <LEFT PAREN> <INT VALUE> <RIGHT PAREN>
| date
<TABLE NAME> ::= <LEGAL IDENTIFIER>
<COLUMN NAME> ::= <LEGAL IDENTIFIER>
<LEGAL IDENTIFIERS> ::= <ALPHABET> (<ALPHABET> | <UNDERSCORE>)*
<UNDERSCORE> ::= _
<LEFT PAREN> ::= (
<RIGHT PAREN> ::= )
<COMMA> ::= ,

*/
void createTableQuery() :
{
  String tableNameString;
  TableElementList definitionList;
  Table newTable = new Table();
}
{
  < CREATE >
  < TABLE >
  tableNameString = tableName()
  definitionList = tableElementList()
  < SEMICOLON >
  {
    try {
	if(tableExist(tableNameString))
	  throw new Exception("Create table has failed: table with the same name already exists");
      
	newTable.setTableName(tableNameString);
	newTable = makeColumns(newTable, definitionList);
	newTable = applyConstraints(newTable, definitionList);
    
	putObjectEntry(tableNameString,newTable);

	System.out.println("'"+ tableNameString +"' table is created");
	}
	catch (Exception e)
	{
		System.out.println(e.getMessage());
		SimpleDBMSParser.ReInit(System.in);
	}
  }
}

TableElementList tableElementList() :
{
  TableElementList definitionList = new TableElementList();
}
{
  < LEFT_PAREN >
  definitionList = tableElement(definitionList)
  (
    < COMMA >
    definitionList = tableElement(definitionList)
  )*
  < RIGHT_PAREN >
  {
	return definitionList;
  }
}

TableElementList tableElement(TableElementList definitionList) :
{
}
{
(   
  definitionList = columnDefinition(definitionList)
| definitionList = tableConstraintDefinition(definitionList)
)
{
  return definitionList;
}
}

TableElementList columnDefinition(TableElementList definitionList) :
{
  String colName;
  String type;
  Token notNull = null;
  ColumnDef newDef;
}
{
(
  colName = columnName()
  type = dataType()
  (
    notNull = < NOT_NULL >
  )?
)
  {
   	newDef = new ColumnDef(colName, type, (notNull==null));
    definitionList.addColumnDef(newDef);
	return definitionList;
  }
}

TableElementList tableConstraintDefinition(TableElementList definitionList) :
{
}
{
(
  definitionList = primaryKeyConstraint(definitionList)
| definitionList = referentialConstraint(definitionList)
)
  {
    return definitionList;
  }
}

TableElementList primaryKeyConstraint(TableElementList definitionList) :
{
  ArrayList<String> columnList;
  TableConstraintDef newDef;
}
{
  < PRIMARY_KEY >
  columnList = columnNameList()
  {
	newDef = new TableConstraintDef("PK", columnList);
	definitionList.addTableConstraintDef(newDef);
	return definitionList;
  }
}

TableElementList referentialConstraint(TableElementList definitionList) :
{
  ArrayList<String> columnList, refColumnList;
  String refTableName;
  TableConstraintDef newDef;
}
{
  < FOREIGN_KEY >
  columnList = columnNameList() 
  < REFERENCES >
  refTableName = tableName()
  refColumnList = columnNameList()
  {
	newDef = new TableConstraintDef("FK", columnList, refTableName, refColumnList);
	definitionList.addTableConstraintDef(newDef);
	return definitionList;
  }
}

ArrayList<String> columnNameList() :
{
  ArrayList<String> result = new ArrayList<String>();
  String temp;
}
{
  < LEFT_PAREN >
  temp = columnName()
  {
	result.add(temp);
  }
  (
    < COMMA >
    temp = columnName()
    {
      result.add(temp);
    }
  )*
  < RIGHT_PAREN >
  {
	return result;
  }
}

String dataType() :
{
  String result;
  Token type = null;
  Token charType = null,lp = null,rp = null,value = null;
}
{
   (    type = < INT >
| (
    charType = < CHAR >
    lp = < LEFT_PAREN >
    value = < INT_VALUE >
    rp = < RIGHT_PAREN >
  )
| type = < DATE >

)
 {
    if (type == null)
    {
      if(Integer.parseInt(value.image) < 1)
      	result = "errorType";
      else
	    result = charType.image+lp.image+value.image+rp.image;
	}
	else result = type.image;
	return result;
 }
}



String tableName() :
{
  Token result;
}
{
  result = < LEGAL_IDENTIFIER >
  {
	return result.image; // PRJ2 #8 : technique that return string
  }
}

String columnName() :
{
  Token result;
}
{
  result = < LEGAL_IDENTIFIER >
  {
	return result.image;
  }
}