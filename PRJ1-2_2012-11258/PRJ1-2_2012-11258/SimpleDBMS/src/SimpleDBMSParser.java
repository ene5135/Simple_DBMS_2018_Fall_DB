/* Generated By:JavaCC: Do not edit this line. SimpleDBMSParser.java */
// import

import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;
import com.sleepycat.je.LockMode;
import com.sleepycat.bind.serial.SerialBinding;
import com.sleepycat.bind.serial.StoredClassCatalog;
import com.sleepycat.bind.EntryBinding;
import com.sleepycat.je.OperationStatus;

import java.io.File;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;

/* PRJ2 #7 : My table, attr structure */
  class Table implements Serializable
  {
        String tableName;
        ArrayList<Attribute> attributes;
        ArrayList<String> referencedBy; // name of table that reference this table.
        ArrayList<ForeignKey> FKs;
        ArrayList<String> PK;

        Table()
        {
          tableName = null;
          attributes = new ArrayList<Attribute>();
          referencedBy = new ArrayList<String>();
          FKs = new ArrayList<ForeignKey>();
          PK = new ArrayList<String>();
        }

        void markPKsNotNull()
        {
          for(String PKCursor : PK)
          {
                for(Attribute attrCursor : attributes)
                {
                  if(PKCursor.equalsIgnoreCase(attrCursor.getAttrName()))
                        attrCursor.setNullable(false);
                }
          }
        }
        Boolean containsCaseInsen(ArrayList<String> arrayList, String target)
    {
          Boolean result = false;
          for(String cursor : arrayList)
          {
            result = result || cursor.equalsIgnoreCase(target);
          }
          return result;
    }
        Boolean containsAttr(String attrName)
        {
          Boolean result = false;
          for(Attribute cursor : attributes)
          {
                if(cursor.getAttrName().equalsIgnoreCase(attrName))
                  result = true;
          }
          return result;
        }
        ArrayList<String> getPK()
        {
          return PK;
        }
        void addToRefBy(String referencingTableName)
        {
          referencedBy.add(referencingTableName);
        }
        ArrayList<ForeignKey> getFKs()
        {
          return FKs;
        }
        void deleteFromRefBy(String target)
        {
          referencedBy.remove(target);
        }
        Boolean isFK(String attrName)
        {
          Boolean result = false;
          for(ForeignKey cursor : FKs)
          {
            result = result || containsCaseInsen(cursor.getAttrs(), attrName);
          }
          return result;
        }
        Boolean isPK(String attrName)
        {
          return containsCaseInsen(PK, attrName);
        }
        ArrayList<Attribute> getAttrs()
        {
          return attributes;
        }
        void addFK(ForeignKey newFK)
        {
          FKs.add(newFK);
        }
        void addPKs(ArrayList<String> newPKs)
        {
          PK.addAll(newPKs);
        }
        String getTableName()
        {
          return tableName;
        }
        Boolean isReferenced()
        {
          return (!referencedBy.isEmpty());
        }
        void setTableName(String argTableName)
        {
          tableName = argTableName;
        }
        void addAttr(Attribute attr)
        {
          attributes.add(attr);
        }
  }

  class Attribute implements Serializable
  {
        String tableName;
        String attrName;
        String type;
        Boolean nullable;

        Attribute()
        {
          tableName = null;
          attrName = null;
          type = null;
          nullable = true;
        }
        Attribute(String argTN, String argAN, String argType, Boolean argNullable)
        {
          tableName = argTN;
          attrName = argAN;
          type = argType;
          nullable = argNullable;
        }

        String getAttrName()
        {
          return attrName;
        }
        String getType()
        {
          return type;
        }
        Boolean getNullable()
        {
          return nullable;
        }
        void setTableName(String argTN)
        {
          tableName = argTN;
        }
        void setAttrName(String argAN)
        {
          attrName = argAN;
        }
        void setType(String argType)
        {
          type = argType;
        }
        void setNullable(Boolean argNullable)
        {
          nullable = argNullable;
        }
  }

  class ForeignKey implements Serializable // Foreign key : list to list referencing
  {
        ArrayList<String> referencingAttrs;
        String referencedTable;
        ArrayList<String> referencedAttrs;

        ForeignKey(ArrayList<String> argReferencing, String argReferencedTable, ArrayList<String> argReferenced)
        {
          referencingAttrs = argReferencing;
          referencedTable = argReferencedTable;
          referencedAttrs = argReferenced;
        }

        String getRefTableName()
        {
          return referencedTable;
        }
        ArrayList<String> getAttrs()
        {
          return referencingAttrs;
        }
  }


////////////// PRJ2 #9 : need these classes to execute column definition before table constraint definition for any order of input statement
  class TableElementList
  {
        ArrayList<ColumnDef> columnDefList;
        ArrayList<TableConstraintDef> tableConstraintDefList;

        TableElementList()
        {
          columnDefList = new ArrayList<ColumnDef>();
          tableConstraintDefList = new ArrayList<TableConstraintDef>();
        }

        ArrayList<TableConstraintDef> getConstDefList()
        {
          return tableConstraintDefList;
        }
        ArrayList<ColumnDef> getColumnDefList()
        {
          return columnDefList;
        }
        void addColumnDef(ColumnDef newDef)
        {
          columnDefList.add(newDef);
        }
        void addTableConstraintDef(TableConstraintDef newDef)
        {
          tableConstraintDefList.add(newDef);
        }
  }

  class ColumnDef
  {
        String columnName;
        String dataType;
        Boolean nullable;

        ColumnDef(String argColName, String argType, Boolean argNullable)
        {
          columnName = argColName;
          dataType = argType;
          nullable = argNullable;
        }

        String getColumnName()
        {
          return columnName;
        }
        String getDataType()
        {
          return dataType;
        }
        Boolean getNullable()
        {
          return nullable;
        }
  }

  class TableConstraintDef
  {
        String type; // "FK" or "PK"
        ArrayList<String> attrs;
        String referencedTable; // for only FK
        ArrayList<String> referencedAttrs; // for only FK

        TableConstraintDef(String argType, ArrayList<String> argAttrs)
        {
          type = argType;
          attrs = argAttrs;
          referencedTable = null;
          referencedAttrs = null;
        }
        TableConstraintDef(String argType, ArrayList<String> argAttrs, String argReferencedTable, ArrayList<String> argReferencedAttrs)
        {
          type = argType;
          attrs = argAttrs;
          referencedTable = argReferencedTable;
          referencedAttrs = argReferencedAttrs;
        }

        String getRefTableName()
        {
          return referencedTable;
        }
        ArrayList<String> getRefAttrs()
        {
          return referencedAttrs;
        }
        ArrayList<String> getAttrs()
        {
          return attrs;
        }
        String getType()
        {
          return type;
        }
  }

public class SimpleDBMSParser implements SimpleDBMSParserConstants {
  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE = 2;
  public static final int PRINT_DESC = 3;
  public static final int PRINT_SELECT = 4;
  public static final int PRINT_INSERT = 5;
  public static final int PRINT_DELETE = 6;
  public static final int PRINT_SHOW_TABLES = 7;

  // Environment & Database declarations
  public static Environment myDbEnvironment = null;
  public static Database myDatabase = null;
  public static Database myClassDb = null;
  public static Cursor cursor = null;
  public static StoredClassCatalog scc = null;
  public static EntryBinding entryBinding = null;
  public static DatabaseEntry foundKey = null;
  public static DatabaseEntry foundData = null;


  public static void main(String args[]) throws ParseException
  {
        /* OPENING DB */

        // Open Database Environment or if not, create one.
        EnvironmentConfig envConfig = new EnvironmentConfig();
        envConfig.setAllowCreate(true);
        myDbEnvironment = new Environment(new File("db/"), envConfig);

        // Open Database or if not, create one.
        // Initializations
        DatabaseConfig dbConfig = new DatabaseConfig();
        dbConfig.setAllowCreate(true);
        dbConfig.setSortedDuplicates(false);
        dbConfig.setDeferredWrite(true); // PRJ2 #1 : set this option to use sync() function.
        myDatabase = myDbEnvironment.openDatabase(null, "sampleDatabase", dbConfig);
        dbConfig.setSortedDuplicates(false);
    myClassDb = myDbEnvironment.openDatabase(null, "classDb", dbConfig);
    scc = new StoredClassCatalog(myClassDb);
        entryBinding = new SerialBinding(scc,Table.class); // PRJ2 #0 : My DB stores <String(=key), Object(=value)>. Techniques to store object in value. using binding
        cursor = myDatabase.openCursor(null, null);
        foundKey = new DatabaseEntry();
        foundData = new DatabaseEntry();

    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
    System.out.print("DB_2012-11258> ");

    while (true)
    {
      try
      {
        parser.command();
      }
      catch (Exception e)
      {
        printMessage(PRINT_SYNTAX_ERROR);
        SimpleDBMSParser.ReInit(System.in);
      }
    }
  }


/* PRJ2 #2 : this function put <Key(=String), Object > into DB. */
  public static void putObjectEntry(String keyString, Object obj) throws Exception
  {
        try {
          DatabaseEntry key;
          DatabaseEntry data;

          key = new DatabaseEntry(keyString.getBytes("UTF-8"));
          data = new DatabaseEntry();

          entryBinding.objectToEntry(obj,data); // PRJ2 #0 : My DB stores <String(=key), Object(=value)>. Techniques to store object in value.

          if(tableExist(keyString))
                // this exception must not be executed
                throw new Exception("Create table has failed: table with the same name already exists");
          myDatabase.putNoOverwrite(null, key, data);
          myDatabase.sync(); // PRJ2 #1 : To save db file immediately.
        } catch (DatabaseException de) {
          de.printStackTrace();
        } catch (UnsupportedEncodingException e) {
          e.printStackTrace();
        }
  }

//PRJ2 #6 : requested message should be removed
  public static void printMessage(int q)
  {
    //System.out.print("DB_2012-11258> ");
    switch(q)
    {
      case PRINT_SYNTAX_ERROR:
        System.out.println("Syntax error");
        break;
        /*
      case PRINT_CREATE_TABLE:
      	System.out.println("\'CREATE TABLE\' requested");
      	break;
      case PRINT_DROP_TABLE:
      	System.out.println("\'DROP TABLE\' requested");
      	break;
      case PRINT_DESC:
      	System.out.println("\'DESC\' requested");
      	break;
      case PRINT_SHOW_TABLES:
	    System.out.println("\'SHOW TABLES\' requested");
      	break;
      	*/
      case PRINT_SELECT:
        System.out.println("\u005c'SELECT\u005c' requested");
        break;
      case PRINT_INSERT:
        System.out.println("\u005c'INSERT\u005c' requested");
        break;
      case PRINT_DELETE:
        System.out.println("\u005c'DELETE\u005c' requested");
        break;
    }
    System.out.print("DB_2012-11258> ");
  }

  static Boolean containsCaseInsen(ArrayList<String> arrayList, String target)
  {
        Boolean result = false;
        for(String cursor : arrayList)
        {
          result = result || cursor.equalsIgnoreCase(target);
        }
        return result;
  }

  static Boolean getTableFromDB(DatabaseEntry theKey, DatabaseEntry theData) // case insensitive get. not found = null
  {
    Boolean result = false;
        if (cursor.getFirst(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.NOTFOUND)
        { // empty db case
          return result;
        }
        else
        {
          do // traverse entire db
          {
            String res_key = null;
            String target = null;
            try {
                        target = new String(theKey.getData(), "UTF-8");
                                res_key = new String(foundKey.getData(), "UTF-8");
                } catch (UnsupportedEncodingException e) {
                        e.printStackTrace();
                }
            if(res_key.equalsIgnoreCase(target))
            {
              entryBinding.objectToEntry((Table) entryBinding.entryToObject(foundData),theData);
              try { theKey.setData(res_key.getBytes("UTF-8")); }
              catch (UnsupportedEncodingException e) {  e.printStackTrace(); }
              result = true;
              return result;
            }
          } while (cursor.getNext(foundKey, foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);
        }
        return result;
  }

  static void addAllReferencedBy(String tableName, TableElementList definitionList) throws Exception
  {
    ArrayList<TableConstraintDef> tableConstraintDefList = definitionList.getConstDefList();
        String refTableName;
        ArrayList<String> keyAttrs, refAttrs;

        for (TableConstraintDef cursor : tableConstraintDefList)
        {
          if(cursor.getType().equals("FK"))
          {
                keyAttrs = cursor.getAttrs();
            refTableName = cursor.getRefTableName();
            refAttrs = cursor.getRefAttrs();

            DatabaseEntry theKey = null;
            try {
                theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        DatabaseEntry theData = new DatabaseEntry();
        if(!getTableFromDB(theKey, theData)) // not found
        {
          //this can not be reached
          throw new Exception("Create table has failed: foreign key references non existing table");
        }
        else // found
        {
              Table retrievedTable = (Table) entryBinding.entryToObject(theData);

              retrievedTable.addToRefBy(tableName);
                  entryBinding.objectToEntry(retrievedTable,theData);
                  myDatabase.put(null, theKey, theData); // overwrite updated record
                  myDatabase.sync();
        }
          }
        }
  }

  static Boolean tableExist(String tableName)
  {
        DatabaseEntry theKey = null;
        try {
                theKey = new DatabaseEntry(tableName.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
        }
    DatabaseEntry theData = new DatabaseEntry();
    return getTableFromDB(theKey, theData);
  }

  static void deleteReference(Table table)
  {
    String referencedTableName;
    for(ForeignKey cursor : table.getFKs())
    {
      referencedTableName = cursor.getRefTableName();
      DatabaseEntry theKey = null;
          try {
                theKey = new DatabaseEntry(referencedTableName.getBytes("UTF-8"));
          } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
          }
      DatabaseEntry theData = new DatabaseEntry();
      if(!getTableFromDB(theKey, theData)) // not found
      {
        System.out.println("Fatal error : code cannot reach here(deleteReference())");
      }
      else // found
      {
            Table retrievedTable = (Table) entryBinding.entryToObject(theData);
            retrievedTable.deleteFromRefBy(table.getTableName());
            entryBinding.objectToEntry(retrievedTable,theData);
                myDatabase.put(null, theKey, theData); // overwrite updated record
                myDatabase.sync();
      }
    }
  }

/* PRJ2 #12 : this function check whether the attr is key or not and return the string like PRI, FOR, PRI/FOR
*/
  static String whatKey(Table table, String attrName)
  {
        String result = new String("");
        String slash = new String("");
        if(table.isPK(attrName))
        {
          result = result + "PRI";
          slash = "/";
        }
        if(table.isFK(attrName))
          result = result + slash + "FOR";

        return result;
  }

/* PRJ2 #10 : this function add new columns to table, traversing column definition list */
  static Table makeColumns(Table newTable, TableElementList definitionList) throws Exception
  {
        ArrayList<ColumnDef> columnDefList = definitionList.getColumnDefList();
        Attribute newAttr;
        String tableName = newTable.getTableName();
        String newColumnName, newColumnType;
        Boolean newColumnNullable;

        for (ColumnDef cursor : columnDefList)
        {
          newColumnName = cursor.getColumnName();
          newColumnType = cursor.getDataType();
          newColumnNullable = cursor.getNullable();

          for(Attribute attrCursor : newTable.getAttrs()) // check dup col
          {
            if(attrCursor.getAttrName().equalsIgnoreCase(newColumnName))
              throw new Exception("Create table has failed: column definition is duplicated");
          }
          if(newColumnType.equals("errorType"))
            throw new Exception("Char length should be over 0");

          newAttr = new Attribute(tableName, newColumnName, newColumnType, newColumnNullable);
          newTable.addAttr(newAttr);
        }

        return newTable;
  }

/* PRJ2 #11 : this function apply new constraints to table, traversing column definition list */
  static Table applyConstraints(Table newTable, TableElementList definitionList) throws Exception
  {
        ArrayList<TableConstraintDef> tableConstraintDefList = definitionList.getConstDefList();
        ForeignKey newForeignKey;
        String refTableName;
        ArrayList<String> keyAttrs, refAttrs;

        for (TableConstraintDef cursor : tableConstraintDefList)
        {
          if(cursor.getType().equals("PK"))
          {
            keyAttrs = cursor.getAttrs();
            if(!newTable.getPK().isEmpty()) // already exist pk
              throw new Exception("Create table has failed: primary key definition is duplicated");

            for(String strCursor : keyAttrs) // 존재하지 않는 컬럼을 primary key로 정의한 경우
                {
                  if(!newTable.containsAttr(strCursor))
                        throw new Exception("Create table has failed: '"+ strCursor +"' does not exists in column definition");
                }

            newTable.addPKs(keyAttrs);
            newTable.markPKsNotNull();
          }
          else // "FK" case
          {
            keyAttrs = cursor.getAttrs();
            refTableName = cursor.getRefTableName();
            refAttrs = cursor.getRefAttrs();

                DatabaseEntry theKey = null;
            try {
                theKey = new DatabaseEntry(refTableName.getBytes("UTF-8"));
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        DatabaseEntry theData = new DatabaseEntry();
        if(!getTableFromDB(theKey, theData)) // not found
        {
          throw new Exception("Create table has failed: foreign key references non existing table");
        }

            Table retrievedTable = (Table) entryBinding.entryToObject(theData);

                ArrayList<Attribute> newTableAttrs = newTable.getAttrs();
                ArrayList<Attribute> refTableAttrs = retrievedTable.getAttrs();
                ArrayList<Attribute> newTableFKAttrs = new ArrayList<Attribute>();
                ArrayList<Attribute> refTableFKAttrs = new ArrayList<Attribute>();
                ArrayList<String> typeList = new ArrayList<String>();

                for(String strCursor : keyAttrs) // 존재하지 않는 컬럼을 foreign key로 정의한 경우
                {
                  if(!newTable.containsAttr(strCursor))
                        throw new Exception("Create table has failed: '"+ strCursor +"' does not exists in column definition");
                }
                for(String strCursor : refAttrs)
                {
                  if(!retrievedTable.containsAttr(strCursor)) // Foreign key가 존재하지 않는 컬럼을 참조한다면, ReferenceColumnExistenceError에 해당하는 메시지 출력
                        throw new Exception("Create table has failed: foreign key references non existing column");
                  if((!containsCaseInsen(retrievedTable.getPK(), strCursor)) || (retrievedTable.getPK().size() != refAttrs.size())) // Foreign key가 primary key가 아닌 컬럼을 참조한다면, 
                        throw new Exception("Create table has failed: foreign key references non primary key column");
                }

                // Foreign key의 타입과 foreign key가 참조하는 컬럼의 개수나 타입이 서로 다른 경우,
                // ReferenceTypeError에 해당하는 메시지 출력
                for(Attribute attrCursor : newTableAttrs)
                {
                  if(containsCaseInsen(keyAttrs, attrCursor.getAttrName()))
                    newTableFKAttrs.add(attrCursor);
                }
                for(Attribute attrCursor : refTableAttrs)
                {
                  if(containsCaseInsen(refAttrs, attrCursor.getAttrName()))
                    refTableFKAttrs.add(attrCursor);
                }

                for(Attribute attrCursor : newTableFKAttrs)
                {
                  typeList.add(attrCursor.getType());
                }
                for(Attribute attrCursor : refTableFKAttrs)
                {
                  typeList.remove(attrCursor.getType());
                }

                if((keyAttrs.size() != refAttrs.size())||(!typeList.isEmpty())) // number of foreign key col and refed col are different 
                  throw new Exception("Create table has failed: foreign key references wrong type");

                for(ForeignKey FKCursor : newTable.getFKs()) // PRJ2 #13 : additional error case. the column references multiple tables
                {
                  for(String newAttr : keyAttrs)
                  {
                        if(containsCaseInsen(FKCursor.getAttrs(), newAttr))
                          throw new Exception("Create table has failed: the column references multiple tables");
                  }
                }

            newForeignKey = new ForeignKey(keyAttrs, refTableName, refAttrs);
            newTable.addFK(newForeignKey);
          }
        }
        addAllReferencedBy(newTable.getTableName(), definitionList);

        return newTable;
  }

///////////////// Query rules ////////////////

/*

<COMMAND> ::= <QUERY LIST>
| exit <SEMICOLON>
<QUERY LIST> ::= (<QUERY> <SEMICOLON>)+
<QUERY> ::= <CREATE TABLE QUERY>
| <DROP TABLE QUERY>
| <DESC QUERY>
| <SELECT QUERY>
| <INSERT QUERY>
| <DELETE QUERY>
| <SHOW TABLES QUERY>
<SEMICOLON> ::= ;

*/
  static final public void command() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE:
    case DROP:
    case DESC:
    case SHOW:
    case SELECT:
    case INSERT:
    case DELETE:
      queryList();
      break;
    case EXIT:
      jj_consume_token(EXIT);
      jj_consume_token(SEMICOLON);
      /* CLOSING DB */
          if (cursor != null) cursor.close();
          if (myDatabase != null) myDatabase.close();
          if (myDatabase != null) myClassDb.close();
          if (myDbEnvironment != null) myDbEnvironment.close();

      System.exit(0);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void queryList() throws ParseException {
  int q;
    label_1:
    while (true) {
      q = query();
      printMessage(q);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CREATE:
      case DROP:
      case DESC:
      case SHOW:
      case SELECT:
      case INSERT:
      case DELETE:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
  }

  static final public int query() throws ParseException {
  int q;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE:
      createTableQuery();
        q = PRINT_CREATE_TABLE;
      break;
    case DROP:
      dropTableQuery();
            q = PRINT_DROP_TABLE;
      break;
    case DESC:
      descQuery();
            q = PRINT_DESC;
      break;
    case SHOW:
      showTablesQuery();
            q = PRINT_SHOW_TABLES;
      break;
    case SELECT:
      selectQuery();
            q = PRINT_SELECT;
      break;
    case INSERT:
      insertQuery();
            q = PRINT_INSERT;
      break;
    case DELETE:
      deleteQuery();
            q = PRINT_DELETE;
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return q;}
    throw new Error("Missing return statement in function");
  }

/////////// delete rules ///////////
/*

<DELETE QUERY> ::= delete from <TABLE NAME> [<WHERE CLAUSE>]

*/
  static final public void deleteQuery() throws ParseException {
    jj_consume_token(DELETE);
    jj_consume_token(FROM);
    tableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      whereClause();
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
  }

/////////// insert rules ////////////////
/*

<INSERT QUERY> ::= insert into <TABLE NAME> <INSERT COLUMNS AND SOURCE>
<INSERT COLUMNS AND SOURCE> ::= [<COLUMN NAME LIST>] <VALUE LIST>
<VALUE LIST> ::= values <LEFT PAREN> <VALUE> (<COMMA> <VALUE>)* <RIGHT PAREN>
<VALUE> ::= null
| <COMPARABLE VALUE>

*/
  static final public void insertQuery() throws ParseException {
    jj_consume_token(INSERT);
    jj_consume_token(INTO);
    tableName();
    insertColumnsAndSource();
    jj_consume_token(SEMICOLON);
  }

  static final public void insertColumnsAndSource() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      columnNameList();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    valueList();
  }

  static final public void valueList() throws ParseException {
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    value();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      value();
    }
    jj_consume_token(RIGHT_PAREN);
  }

  static final public void value() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      jj_consume_token(NULL);
      break;
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      comparableValue();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/////////// select rules /////////////////
/*

<SELECT QUERY> ::= select <SELECT LIST> <TABLE EXPRESSION>
<SELECT LIST> ::= *
| <SELECTED COLUMN> (<COMMA> <SELECTED COLUMN>)*
<SELECTED COLUMN> ::= [<TABLE NAME> <PERIOD>] <COLUMN NAME> [as <COLUMN NAME>]
<PERIOD> ::= .
<TABLE EXPRESSION> ::= <FROM CLAUSE> [<WHERE CLAUSE>]
<FROM CLAUSE> ::= from <TABLE REFERENCE LIST>
<TABLE REFERENCE LIST> ::= <REFERED TABLE> (<COMMA> <REFERED TABLE>)*
<REFERED TABLE> ::= <TABLE NAME> [as <TABLE NAME>]
<WHERE CLAUSE> ::= where <BOOLEAN VALUE EXPRESSION>
<BOOLEAN VALUE EXPRESSION> ::= <BOOLEAN TERM> ( or <BOOLEAN TERM>)*
<BOOLEAN TERM> ::= <BOOLEAN FACTOR>( and <BOOLEAN FACTOR> )*
<BOOLEAN FACTOR> ::= [not] <BOOLEAN TEST>
<BOOLEAN TEST> ::= <PREDICATE>
| <PARENTHESIZED BOOLEAN EXPRESSION>
<PARENTHESIZED BOOLEAN EXPRESSION> ::= <LEFT PAREN> <BOOLEAN VALUE EXPRESSION> <RIGHT PAREN>
<PREDICATE> ::= <COMPARISON PREDICATE>
| <NULL PREDICTE>
<COMPARISON PREDICATE> ::= <COMP OPERAND> <COMP OP> <COMP OPERAND>
<COMP OPERAND> ::= <COMPARABLE VALUE>
| [<TABLE NAME> <PERIOD>] <COLUMN NAME>
<COMP OP> ::= < | > | = | >= | <= | !=
<COMPARABLE VALUE> ::= <INT VALUE>
| <CHAR STRING>
| <DATE VALUE>
<NULL PREDICATE> ::= [<TABLE NAME> <PERIOD>] <COLUMN NAME> <NULL OPERATION>
<NULL OPERATION> ::= is [not] null

*/
  static final public void selectQuery() throws ParseException {
    jj_consume_token(SELECT);
    selectList();
    tableExpression();
    jj_consume_token(SEMICOLON);
  }

  static final public void selectList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
      jj_consume_token(ASTERISK);
      break;
    case LEGAL_IDENTIFIER:
      selectedColumn();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_3;
        }
        jj_consume_token(COMMA);
        selectedColumn();
      }
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void selectedColumn() throws ParseException {
    if (jj_2_1(2)) {
      tableName();
      jj_consume_token(PERIOD);
    } else {
      ;
    }
    columnName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      columnName();
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
  }

  static final public void tableExpression() throws ParseException {
    fromClause();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      whereClause();
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
  }

  static final public void fromClause() throws ParseException {
    jj_consume_token(FROM);
    tableReferenceList();
  }

  static final public void tableReferenceList() throws ParseException {
    referedTable();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      referedTable();
    }
  }

  static final public void referedTable() throws ParseException {
    tableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      tableName();
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
  }

  static final public void whereClause() throws ParseException {
    jj_consume_token(WHERE);
    booleanValueExpression();
  }

  static final public void booleanValueExpression() throws ParseException {
    booleanTerm();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_5;
      }
      jj_consume_token(OR);
      booleanTerm();
    }
  }

  static final public void booleanTerm() throws ParseException {
    booleanFactor();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_6;
      }
      jj_consume_token(AND);
      booleanFactor();
    }
  }

  static final public void booleanFactor() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    booleanTest();
  }

  static final public void booleanTest() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case LEGAL_IDENTIFIER:
    case CHAR_STRING:
    case DATE_VALUE:
      predicate();
      break;
    case LEFT_PAREN:
      parenthesizedBooleanExpression();
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void parenthesizedBooleanExpression() throws ParseException {
    jj_consume_token(LEFT_PAREN);
    booleanValueExpression();
    jj_consume_token(RIGHT_PAREN);
  }

  static final public void predicate() throws ParseException {
    if (jj_2_2(4)) {
      comparisonPredicate();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEGAL_IDENTIFIER:
        nullPredicate();
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public void comparisonPredicate() throws ParseException {
    compOperand();
    compOp();
    compOperand();
  }

  static final public void compOperand() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      comparableValue();
      break;
    case LEGAL_IDENTIFIER:
      if (jj_2_3(2)) {
        tableName();
        jj_consume_token(PERIOD);
      } else {
        ;
      }
      columnName();
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void compOp() throws ParseException {
    jj_consume_token(COMPARISON_SIGNS);
  }

  static final public void comparableValue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
      jj_consume_token(INT_VALUE);
      break;
    case CHAR_STRING:
      jj_consume_token(CHAR_STRING);
      break;
    case DATE_VALUE:
      jj_consume_token(DATE_VALUE);
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void nullPredicate() throws ParseException {
    if (jj_2_4(2)) {
      tableName();
      jj_consume_token(PERIOD);
    } else {
      ;
    }
    columnName();
    nullOperation();
  }

  static final public void nullOperation() throws ParseException {
    jj_consume_token(IS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT_NULL:
      jj_consume_token(NOT_NULL);
      break;
    case NULL:
      jj_consume_token(NULL);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/////////// show table rules ///////////
/*

<SHOW TABLES QUERY> ::= show tables

*/
  static final public void showTablesQuery() throws ParseException {
    jj_consume_token(SHOW);
    jj_consume_token(TABLES);
    jj_consume_token(SEMICOLON);
        /* PRJ2 #3 : implementation of show tables */

        if (cursor.getFirst(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.NOTFOUND)
        { // empty db case
          System.out.println("There is no table");
        }
        else
        {
          System.out.println("----------------");
          do // traverse entire db
          {
            String res_key = null;
            try {
                                res_key = new String(foundKey.getData(), "UTF-8");
                } catch (UnsupportedEncodingException e) {
                        e.printStackTrace();
                }
            System.out.println(res_key);
          } while (cursor.getNext(foundKey, foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);
          System.out.println("----------------");
        }
  }

/////////// desc rules ////////////
/*

<DESC QUERY> ::= desc <TABLE NAME>

*/
// PRJ2 #11 : implementation of desc
  static final public void descQuery() throws ParseException {
  String keyString;
    jj_consume_token(DESC);
    keyString = tableName();
    jj_consume_token(SEMICOLON);
    try {
    // get table object from db
    DatabaseEntry theKey = null;
        try {
                theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
        }
    DatabaseEntry theData = new DatabaseEntry();
    String attrName, attrType, attrNullable;
    if(!getTableFromDB(theKey, theData)) // not found
    {
      System.out.println("No such table");
    }
    else // found
    {
      // the EntryBinding created above
      Table retrievedTable = (Table) entryBinding.entryToObject(theData);

          System.out.println("-------------------------------------------------");
          System.out.println("table_name ["+retrievedTable.getTableName()+"]");
          System.out.printf("%-19s%-10s%-10s%-10s\u005cn", "column_name","type","null","key");

          for(Attribute cursor : retrievedTable.getAttrs())
          {
            attrName = cursor.getAttrName();
            attrType = cursor.getType();
            if(cursor.getNullable())
              attrNullable = "Y";
            else
              attrNullable = "N";
            System.out.printf("%-19s%-10s%-10s%-10s\u005cn", attrName, attrType, attrNullable, whatKey(retrievedTable, attrName));
          }

          System.out.println("-------------------------------------------------");
        }
        } catch (Exception e) { e.printStackTrace(); }
  }

/////////// drop table rules /////////////
/*

<DROP TABLE QUERY> ::= drop table <TABLE NAME>

*/

// PRJ2 #12 : implementation of drop table
  static final public void dropTableQuery() throws ParseException {
  String keyString;
    jj_consume_token(DROP);
    jj_consume_token(TABLE);
    keyString = tableName();
    jj_consume_token(SEMICOLON);
        // get table object from db
    DatabaseEntry theKey = null;
        try {
                theKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
        }
    DatabaseEntry theData = new DatabaseEntry();
    if(!getTableFromDB(theKey, theData)) // not found
    {
      System.out.println("No such table");
    }
    else // found
    {
      Table retrievedTable = (Table) entryBinding.entryToObject(theData);
          if(retrievedTable.isReferenced())
                System.out.println("Drop table has failed: '"+ keyString +"' is referenced by other table");
          else
          {
                deleteReference(retrievedTable); // delete this table from referencedBy list of other referenced table
                myDatabase.delete(null, theKey);
                myDatabase.sync();
                System.out.println("'"+ keyString +"' table is dropped");
          }
    }
  }

/////////// create table rules ///////////////
/*

<CREATE TABLE QUERY> ::= create table <TABLE NAME> <TABLE ELEMENT LIST>
<TABLE ELEMENT LIST> ::= <LEFT PAREN> <TABLE ELEMENT> (<COMMA> <TABLE ELEMENT>)* <RIGHT PAREN>
<TABLE ELEMENT> ::= <COLUMN DEFINITION>
| <TABLE CONSTRAINT DEFINITION>
<COLUMN DEFINITION> ::= <COLUMN NAME> <DATA TYPE> [not null]
<TABLE CONSTRAINT DEFINITION> ::= <PRIMARY KEY CONSTRAINT>
| <REFERENTIAL CONSTRAINT>
<PRIMARY KEY CONSTRAINT> ::= primary key <COLUMN NAME LIST>
<REFERENTIAL CONSTRAINT> ::= foreign key <COLUMN NAME LIST> references <TABLE NAME> <COLUMN NAME LIST>
<COLUMN NAME LIST> ::= <LEFT PAREN> <COLUMN NAME> (<COMMA> <COLUMN NAME>)* <RIGHT PAREN>
<DATA TYPE> ::= int
| char <LEFT PAREN> <INT VALUE> <RIGHT PAREN>
| date
<TABLE NAME> ::= <LEGAL IDENTIFIER>
<COLUMN NAME> ::= <LEGAL IDENTIFIER>
<LEGAL IDENTIFIERS> ::= <ALPHABET> (<ALPHABET> | <UNDERSCORE>)*
<UNDERSCORE> ::= _
<LEFT PAREN> ::= (
<RIGHT PAREN> ::= )
<COMMA> ::= ,

*/
  static final public void createTableQuery() throws ParseException {
  String tableNameString;
  TableElementList definitionList;
  Table newTable = new Table();
    jj_consume_token(CREATE);
    jj_consume_token(TABLE);
    tableNameString = tableName();
    definitionList = tableElementList();
    jj_consume_token(SEMICOLON);
    try {
        if(tableExist(tableNameString))
          {if (true) throw new Exception("Create table has failed: table with the same name already exists");}

        newTable.setTableName(tableNameString);
        newTable = makeColumns(newTable, definitionList);
        newTable = applyConstraints(newTable, definitionList);

        putObjectEntry(tableNameString,newTable);

        System.out.println("'"+ tableNameString +"' table is created");
        }
        catch (Exception e)
        {
                System.out.println(e.getMessage());
                SimpleDBMSParser.ReInit(System.in);
        }
  }

  static final public TableElementList tableElementList() throws ParseException {
  TableElementList definitionList = new TableElementList();
    jj_consume_token(LEFT_PAREN);
    definitionList = tableElement(definitionList);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_7;
      }
      jj_consume_token(COMMA);
      definitionList = tableElement(definitionList);
    }
    jj_consume_token(RIGHT_PAREN);
        {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public TableElementList tableElement(TableElementList definitionList) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      definitionList = columnDefinition(definitionList);
      break;
    case PRIMARY_KEY:
    case FOREIGN_KEY:
      definitionList = tableConstraintDefinition(definitionList);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public TableElementList columnDefinition(TableElementList definitionList) throws ParseException {
  String colName;
  String type;
  Token notNull = null;
  ColumnDef newDef;
    colName = columnName();
    type = dataType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT_NULL:
      notNull = jj_consume_token(NOT_NULL);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
        newDef = new ColumnDef(colName, type, (notNull==null));
    definitionList.addColumnDef(newDef);
        {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public TableElementList tableConstraintDefinition(TableElementList definitionList) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY_KEY:
      definitionList = primaryKeyConstraint(definitionList);
      break;
    case FOREIGN_KEY:
      definitionList = referentialConstraint(definitionList);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public TableElementList primaryKeyConstraint(TableElementList definitionList) throws ParseException {
  ArrayList<String> columnList;
  TableConstraintDef newDef;
    jj_consume_token(PRIMARY_KEY);
    columnList = columnNameList();
        newDef = new TableConstraintDef("PK", columnList);
        definitionList.addTableConstraintDef(newDef);
        {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public TableElementList referentialConstraint(TableElementList definitionList) throws ParseException {
  ArrayList<String> columnList, refColumnList;
  String refTableName;
  TableConstraintDef newDef;
    jj_consume_token(FOREIGN_KEY);
    columnList = columnNameList();
    jj_consume_token(REFERENCES);
    refTableName = tableName();
    refColumnList = columnNameList();
        newDef = new TableConstraintDef("FK", columnList, refTableName, refColumnList);
        definitionList.addTableConstraintDef(newDef);
        {if (true) return definitionList;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> columnNameList() throws ParseException {
  ArrayList<String> result = new ArrayList<String>();
  String temp;
    jj_consume_token(LEFT_PAREN);
    temp = columnName();
        result.add(temp);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      temp = columnName();
      result.add(temp);
    }
    jj_consume_token(RIGHT_PAREN);
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public String dataType() throws ParseException {
  String result;
  Token type = null;
  Token charType = null,lp = null,rp = null,value = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      type = jj_consume_token(INT);
      break;
    case CHAR:
      charType = jj_consume_token(CHAR);
      lp = jj_consume_token(LEFT_PAREN);
      value = jj_consume_token(INT_VALUE);
      rp = jj_consume_token(RIGHT_PAREN);
      break;
    case DATE:
      type = jj_consume_token(DATE);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (type == null)
    {
      if(Integer.parseInt(value.image) < 1)
        result = "errorType";
      else
            result = charType.image+lp.image+value.image+rp.image;
        }
        else result = type.image;
        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public String tableName() throws ParseException {
  Token result;
    result = jj_consume_token(LEGAL_IDENTIFIER);
        {if (true) return result.image;} // PRJ2 #8 : technique that return string

    throw new Error("Missing return statement in function");
  }

  static final public String columnName() throws ParseException {
  Token result;
    result = jj_consume_token(LEGAL_IDENTIFIER);
        {if (true) return result.image;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_3R_10() {
    if (jj_3R_11()) return true;
    if (jj_scan_token(47)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  static private boolean jj_3R_15() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_10()) return true;
    return false;
  }

  static private boolean jj_3R_9() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_3R_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) jj_scanpos = xsp;
    if (jj_3R_15()) return true;
    return false;
  }

  static private boolean jj_3R_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) return true;
    }
    return false;
  }

  static private boolean jj_3R_12() {
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) return true;
    }
    }
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public SimpleDBMSParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[27];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x1700220,0x1700200,0x1700200,0x10000000,0x0,0x0,0x1000,0x0,0x2000000,0x4000000,0x10000000,0x0,0x4000000,0x20000000,0x40000000,0x800,0x0,0x0,0x0,0x0,0x3000,0x0,0x60000,0x2000,0x60000,0x0,0x1c0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x9,0x9,0x9,0x0,0x20,0x80,0x180200,0x80,0x1000,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x181220,0x1000,0x181200,0x180200,0x0,0x80,0x1000,0x0,0x0,0x80,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[4];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SimpleDBMSParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleDBMSParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SimpleDBMSParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SimpleDBMSParser(SimpleDBMSParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SimpleDBMSParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[55];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 27; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 55; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
